From bce91e0854a0ff1d0b2023f1f3a54077a36e3738 Mon Sep 17 00:00:00 2001
From: Christian Lohmaier <lohmaier+LibreOffice@googlemail.com>
Date: Mon, 23 Aug 2021 15:10:08 +0100
Subject: [PATCH] tdf#101630 - gdrive support w/oAuth and Drive API v3

LibreOffice is only using drive.file scope, so can only see files it
owns/that were created by LibreOffice.

In addition, also store the refresh token in LO's password-store if the
user enabled persistent storage, removing the need to to the
copy'n'paste dance to grant access each time LO is launched.

related tdf#115643 also store the refresh token for onedrive
consolidate the fallback-auth provides for onedrive/gdrive into one,
they are all the same login in browser, then copy code method that
ultimately should be changed to having LO listen on local port for the
code
---
 inc/libcmis/session.hxx           |   2 +
 src/libcmis/gdrive-document.cxx   |  49 ++------
 src/libcmis/gdrive-folder.cxx     |  25 ++--
 src/libcmis/gdrive-object.cxx     |  43 +++----
 src/libcmis/gdrive-repository.cxx |   2 +-
 src/libcmis/gdrive-session.cxx    |  76 ++++++++++-
 src/libcmis/gdrive-session.hxx    |   8 ++
 src/libcmis/gdrive-utils.cxx      |  33 ++---
 src/libcmis/gdrive-utils.hxx      |   3 +-
 src/libcmis/http-session.hxx      |   2 +-
 src/libcmis/oauth2-handler.cxx    |  16 ++-
 src/libcmis/oauth2-handler.hxx    |   1 +
 src/libcmis/oauth2-providers.cxx  | 203 +-----------------------------
 src/libcmis/oauth2-providers.hxx  |   6 +-
 src/libcmis/onedrive-session.cxx  |  39 ++++++
 src/libcmis/onedrive-session.hxx  |  10 +-
 src/libcmis/session-factory.cxx   |   2 +-
 17 files changed, 206 insertions(+), 314 deletions(-)

diff --git a/inc/libcmis/session.hxx b/inc/libcmis/session.hxx
index 0a768a8..ec95ab4 100644
--- a/inc/libcmis/session.hxx
+++ b/inc/libcmis/session.hxx
@@ -95,6 +95,8 @@ namespace libcmis
                 certificate exception feature available on common web browser.
               */
             virtual void setNoSSLCertificateCheck( bool noCheck ) = 0;
+
+            virtual std::string getRefreshToken() { return ""; };
     };
 }
 
diff --git a/src/libcmis/gdrive-document.cxx b/src/libcmis/gdrive-document.cxx
index fe7b73a..ecb13d6 100644
--- a/src/libcmis/gdrive-document.cxx
+++ b/src/libcmis/gdrive-document.cxx
@@ -145,23 +145,17 @@ void GDriveDocument::uploadStream( boost::shared_ptr< ostream > os,
 {
     if ( !os.get( ) )
         throw libcmis::Exception( "Missing stream" );
-    if ( !isImmutable( ) )
-        throw libcmis::Exception( string ( "Document " + getId( )+ 
-                                    " is not editable" ) );
-    string putUrl = getUploadUrl( ) + getId( );
-    putUrl += "?uploadType=media";
-    
-    // If it's a Google document, convert it 
-    if ( isGoogleDoc( ) )
-        putUrl  += "&convert=true";
+
+    string putUrl = GDRIVE_UPLOAD_LINK + getId( ) + "?uploadType=media";
 
     // Upload stream
     boost::shared_ptr< istream> is ( new istream ( os->rdbuf( ) ) );
     vector <string> headers;
     headers.push_back( string( "Content-Type: " ) + contentType );
+    string res;
     try
     {
-        getSession()->httpPutRequest( putUrl, *is, headers );
+        res = getSession()->httpPatchRequest( putUrl, *is, headers )->getStream()->str();
     }
     catch ( const CurlException& e )
     {
@@ -181,35 +175,10 @@ void GDriveDocument::setContentStream( boost::shared_ptr< ostream > os,
 {
     if ( !os.get( ) )
         throw libcmis::Exception( "Missing stream" );
-    
-    if ( !isImmutable( ) )
-        throw libcmis::Exception( string ( "Document " + getId( )+ 
-                                    " is not editable" ) );
-    string metaUrl = getUrl( );
-
-    // If it's a Google document, convert it 
-    if ( isGoogleDoc( ) )
-        metaUrl += "?convert=true";
-
-    // Update file name meta information
-    if ( !fileName.empty( ) && fileName != getContentFilename( ) )
-    {
-        Json metaJson;
-        Json fileJson( fileName.c_str( ) );
-        metaJson.add("title", fileJson );
 
-        std::istringstream is( metaJson.toString( ) );
-        vector<string> headers;
-        headers.push_back( "Content-Type: application/json" );
-        try
-        {
-            getSession()->httpPutRequest( metaUrl, is, headers );
-        }
-        catch ( const CurlException& e )
-        {
-            throw e.getCmisException( );
-        }
-    }
+    // TODO: when would the filename need an update?
+    if (!fileName.empty() && fileName != getContentFilename())
+        std::cout << "filename change is not implemented in setContentStream" << std::endl;
 
     // Upload stream
     uploadStream( os, contentType );
@@ -251,7 +220,7 @@ libcmis::DocumentPtr GDriveDocument::checkIn(
 vector< libcmis::DocumentPtr > GDriveDocument::getAllVersions( ) 
 {   
     vector< libcmis::DocumentPtr > revisions;
-    string versionUrl = getUrl( ) + "/revisions";
+    string versionUrl = GDRIVE_METADATA_LINK + getId( ) + "/revisions";
     // Run the http request to get the properties definition
     string res;
     try
@@ -263,7 +232,7 @@ vector< libcmis::DocumentPtr > GDriveDocument::getAllVersions( )
         throw e.getCmisException( );
     }
     Json jsonRes = Json::parse( res );        
-    Json::JsonVector objs = jsonRes["items"].getList( );
+    Json::JsonVector objs = jsonRes["revisions"].getList( );
    
     string parentId = getStringProperty( "cmis:parentId" );
 
diff --git a/src/libcmis/gdrive-folder.cxx b/src/libcmis/gdrive-folder.cxx
index 34ab187..26de89b 100644
--- a/src/libcmis/gdrive-folder.cxx
+++ b/src/libcmis/gdrive-folder.cxx
@@ -62,8 +62,8 @@ vector< libcmis::ObjectPtr > GDriveFolder::getChildren( )
     // Instead of sending multiple queries for children,
     // we send a single query to search for objects where parents
     // include the folderID.
-    string query = getSession( )->getBindingUrl( ) + 
-        "/files?q=\"" + getId( ) + "\"+in+parents+and+trashed+=+false";
+    string query = GDRIVE_METADATA_LINK + "?q=\"" + getId( ) + "\"+in+parents+and+trashed+=+false" +
+        "&fields=files(kind,id,name,parents,mimeType,createdTime,modifiedTime,thumbnailLink,size)";
 
     string res;
     try
@@ -76,7 +76,7 @@ vector< libcmis::ObjectPtr > GDriveFolder::getChildren( )
     }
 
     Json jsonRes = Json::parse( res );
-    Json::JsonVector objs = jsonRes["items"].getList( );
+    Json::JsonVector objs = jsonRes["files"].getList( );
     
     // Create children objects from Json objects
     for(unsigned int i = 0; i < objs.size(); i++)
@@ -95,7 +95,7 @@ vector< libcmis::ObjectPtr > GDriveFolder::getChildren( )
 string GDriveFolder::uploadProperties( Json properties )
 {
     // URL for uploading meta data
-    string metaUrl =  getSession()->getBindingUrl() + "/files/";
+    string metaUrl =  GDRIVE_METADATA_LINK + "?fields=kind,id,name,parents,mimeType,createdTime,modifiedTime";
 
     // add parents to the properties    
     properties.add( "parents", GdriveUtils::createJsonFromParentId( getId( ) ) );
@@ -147,9 +147,15 @@ libcmis::DocumentPtr GDriveFolder::createDocument(
     
     Json propsJson = GdriveUtils::toGdriveJson( properties );
 
-    // Add filename to properties
-    Json jsonFilename( fileName.c_str( ) );
-    propsJson.add( "title", jsonFilename );
+    if(!fileName.empty()) {
+        // use provided filename
+        Json jsonFilename( fileName.c_str( ) );
+
+        propsJson.add( "name", jsonFilename );
+    }
+    if(!contentType.empty()) {
+        propsJson.add( "mimeType", Json(contentType.c_str()));
+    }
     
     // Upload meta-datas
     string res = uploadProperties( propsJson);
@@ -171,12 +177,9 @@ vector< string > GDriveFolder::removeTree(
     libcmis::UnfileObjects::Type /*unfile*/, 
     bool /*continueOnError*/ ) 
 {
-    // Object remove doesn't work with folder
-    // Using trash instead
     try
     {   
-        istringstream is( "" );
-        getSession( )->httpPostRequest( getUrl( ) + "/trash", is, "" );
+        getSession( )->httpDeleteRequest( GDRIVE_METADATA_LINK + getId( ) );
     }
     catch ( const CurlException& e )
     {
diff --git a/src/libcmis/gdrive-object.cxx b/src/libcmis/gdrive-object.cxx
index f22c240..b472e2f 100644
--- a/src/libcmis/gdrive-object.cxx
+++ b/src/libcmis/gdrive-object.cxx
@@ -89,8 +89,8 @@ void GDriveObject::initializeFromJson ( Json json, string id, string name )
             property.reset( new GDriveProperty( it->first, it->second ) );
             m_properties[ property->getPropertyType( )->getId()] = property;
            
-            // we map "title" to both "cmis:name" and "cmis:getContentStreamFileName"
-            if ( it->first == "title" )
+            // we map "name" to both "cmis:name" and "cmis:getContentStreamFileName"
+            if ( it->first == "name" )
             {
                 property.reset( new GDriveProperty( "cmis:name", it->second) );
                 m_properties[ property->getPropertyType( )->getId()] = property;
@@ -142,16 +142,13 @@ vector< RenditionPtr> GDriveObject::getRenditions( string /* filter */ )
 {
     if ( m_renditions.empty( ) )
     {
-        string downloadUrl = getStringProperty( "downloadUrl" );
-        if ( !downloadUrl.empty( ) )
+        string downloadUrl = GDRIVE_METADATA_LINK + getId( ) + "?alt=media";
+        string mimeType = getStringProperty( "cmis:contentStreamMimeType" );
+        if ( !mimeType.empty( ) )
         {
-            string mimeType = getStringProperty( "cmis:contentStreamMimeType" );
-            if ( !mimeType.empty( ) )
-            { 
-                RenditionPtr rendition( 
-                    new Rendition( mimeType, mimeType, mimeType, downloadUrl ));
-                m_renditions.push_back( rendition );
-            }
+            RenditionPtr rendition(
+                new Rendition( mimeType, mimeType, mimeType, downloadUrl ));
+            m_renditions.push_back( rendition );
         }
 
         vector< string > exportLinks = getMultiStringProperty( "exportLinks" );
@@ -159,7 +156,7 @@ vector< RenditionPtr> GDriveObject::getRenditions( string /* filter */ )
         { 
             int pos = (*it).find(":\"");
             if ( pos == -1 ) continue;
-            string mimeType = (*it).substr( 0, pos );
+            mimeType = (*it).substr( 0, pos );
             string url = (*it).substr( pos + 2, (*it).length( ) - pos - 3 );
             RenditionPtr rendition(
                 new Rendition( mimeType, mimeType, mimeType, url ) );
@@ -170,7 +167,7 @@ vector< RenditionPtr> GDriveObject::getRenditions( string /* filter */ )
         string thumbnailLink = getStringProperty( "thumbnailLink" );
         if ( !thumbnailLink.empty( ) )
         {
-            string mimeType = "cmis:thumbnail";   
+            mimeType = "cmis:thumbnail";
             RenditionPtr rendition( 
                 new Rendition( mimeType, mimeType, mimeType, thumbnailLink ));
             m_renditions.push_back( rendition );
@@ -192,7 +189,7 @@ libcmis::ObjectPtr GDriveObject::updateProperties(
     {   
         vector< string > headers;
         headers.push_back( "Content-Type: application/json" );
-        response = getSession( )->httpPutRequest( getUrl( ), is, headers );
+        response = getSession( )->httpPatchRequest( getUrl( ), is, headers );
     }
     catch ( const CurlException& e )
     {   
@@ -228,7 +225,7 @@ void GDriveObject::remove( bool /*allVersions*/ )
 {
     try
     {
-        getSession( )->httpDeleteRequest( getUrl( ) );
+        getSession( )->httpDeleteRequest( GDRIVE_METADATA_LINK + getId( ) );
     }
     catch ( const CurlException& e )
     {
@@ -239,8 +236,8 @@ void GDriveObject::remove( bool /*allVersions*/ )
 void GDriveObject::move( FolderPtr /*source*/, FolderPtr destination ) 
 {  
     Json parentsJson;
-    Json parentsValue = GdriveUtils::createJsonFromParentId( destination->getId( ) );
-    parentsJson.add( "parents", parentsValue );
+    parentsJson.add( "addParents", Json(destination->getId( ).c_str()) );
+    parentsJson.add( "removeParents", Json(getStringProperty( "cmis:parentId" ).c_str()) );
     
     istringstream is( parentsJson.toString( ) );
     libcmis::HttpResponsePtr response;
@@ -248,7 +245,7 @@ void GDriveObject::move( FolderPtr /*source*/, FolderPtr destination )
     {   
         vector< string > headers;
         headers.push_back( "Content-Type: application/json" );
-        response = getSession( )->httpPutRequest( getUrl( ), is, headers );
+        response = getSession( )->httpPatchRequest( getUrl( ), is, headers );
     }
     catch ( const CurlException& e )
     {   
@@ -262,12 +259,10 @@ void GDriveObject::move( FolderPtr /*source*/, FolderPtr destination )
 
 string GDriveObject::getUrl( )
 {
-    return getSession( )->getBindingUrl( ) + "/files/" + getId( );
-}
-
-string GDriveObject::getUploadUrl( )
-{
-    return GDRIVE_UPLOAD_LINKS;
+    // thumbnailLink causes some operations to fail with internal server error,
+    // see https://issuetracker.google.com/issues/36760667
+    return GDRIVE_METADATA_LINK + getId( ) +
+                "?fields=kind,id,name,parents,mimeType,createdTime,modifiedTime,size";
 }
 
 vector< string> GDriveObject::getMultiStringProperty( const string& propertyName )
diff --git a/src/libcmis/gdrive-repository.cxx b/src/libcmis/gdrive-repository.cxx
index e6cec69..24b42b5 100644
--- a/src/libcmis/gdrive-repository.cxx
+++ b/src/libcmis/gdrive-repository.cxx
@@ -35,7 +35,7 @@ GdriveRepository::GdriveRepository( ) :
     m_name = "Google Drive";
     m_description = "Google Drive repository";
     m_productName = "Google Drive";
-    m_productVersion = "v2";
+    m_productVersion = "v3";
     m_rootId = "root";
  
     m_capabilities[ ACL ] = "discover";
diff --git a/src/libcmis/gdrive-session.cxx b/src/libcmis/gdrive-session.cxx
index 87bb160..1ee748e 100644
--- a/src/libcmis/gdrive-session.cxx
+++ b/src/libcmis/gdrive-session.cxx
@@ -65,6 +65,46 @@ GDriveSession::~GDriveSession()
 {
 }
 
+
+void GDriveSession::setOAuth2Data( libcmis::OAuth2DataPtr oauth2 )
+{
+    m_oauth2Handler = new OAuth2Handler( this, oauth2 );
+    m_oauth2Handler->setOAuth2Parser( OAuth2Providers::getOAuth2Parser( getBindingUrl( ) ) );
+
+    oauth2Authenticate( );
+}
+
+void GDriveSession::oauth2Authenticate()
+{
+    // treat the supplied password as refresh token
+    if (!m_password.empty())
+    {
+        try
+        {
+            m_inOAuth2Authentication = true;
+
+            m_oauth2Handler->setRefreshToken(m_password);
+            // Try to get new access tokens using the stored refreshtoken
+            m_oauth2Handler->refresh();
+            m_inOAuth2Authentication = false;
+        }
+        catch (const CurlException &e)
+        {
+            m_inOAuth2Authentication = false;
+            // refresh token expired or invalid, trigger initial auth (that in turn will hit the fallback with copy'n'paste method)
+            BaseSession::oauth2Authenticate();
+        }
+    }
+    else
+    {
+        BaseSession::oauth2Authenticate();
+    }
+}
+
+string GDriveSession::getRefreshToken() {
+    return HttpSession::getRefreshToken();
+}
+
 libcmis::RepositoryPtr GDriveSession::getRepository( )
 {
     // Return a dummy repository since GDrive doesn't have that notion
@@ -79,9 +119,13 @@ bool GDriveSession::setRepository( std::string )
 
 libcmis::ObjectPtr GDriveSession::getObject( string objectId )
 {
+    if(objectId == "root") {
+        return getRootFolder();
+    }
     // Run the http request to get the properties definition
     string res;
-    string objectLink = m_bindingUrl + "/files/" + objectId;
+    string objectLink = GDRIVE_METADATA_LINK + objectId +
+         "?fields=kind,id,name,parents,mimeType,createdTime,modifiedTime,thumbnailLink,size";
     try
     {
         res = httpGetRequest( objectLink )->getStream()->str();
@@ -143,9 +187,10 @@ libcmis::ObjectPtr GDriveSession::getObjectByPath( string path )
         {
             // Normal child case
             // Ask for the ID of the child if there is any
-            string childIdUrl = m_bindingUrl + "/files/" + objectId +
-                                "/children/?q=title+=+'" + segment +
-                                "'&fields=items:id";
+            // somewhat flawed as names are not necessarily unique in GDrive...
+            string query = libcmis::escape("'" + objectId + "' in parents and trashed = false and name='" + segment + "'");
+
+            string childIdUrl = m_bindingUrl + "/files/?q=" + query + "&fields=files(id)";
 
             string res;
             try
@@ -159,7 +204,7 @@ libcmis::ObjectPtr GDriveSession::getObjectByPath( string path )
             Json jsonRes = Json::parse( res );
 
             // Did we get an id?
-            Json::JsonVector items = jsonRes["items"].getList();
+            Json::JsonVector items = jsonRes["files"].getList();
             if ( items.empty( ) )
                 throw libcmis::Exception( "Object not found: " + path, "objectNotFound" );
 
@@ -174,6 +219,27 @@ libcmis::ObjectPtr GDriveSession::getObjectByPath( string path )
     return getObject( objectId );
 }
 
+libcmis::FolderPtr GDriveSession::getRootFolder()
+{
+    // permissions/scope with just drive.file don't allow to get it with the "root" alias/by its actual object-ID
+    Json propsJson;
+
+    // GDrive folder is a file with a different mime type.
+    string mimeType = GDRIVE_FOLDER_MIME_TYPE;
+
+    // Add mimetype to the propsJson
+    Json jsonMimeType( mimeType.c_str( ) );
+    propsJson.add( "mimeType", jsonMimeType );
+    propsJson.add( "id", "root" );
+
+    // Upload meta-datas
+    propsJson.add("cmis:name", "VirtualRoot");
+
+    libcmis::FolderPtr folderPtr( new GDriveFolder( this, propsJson ) );
+
+    return folderPtr;
+}
+
 libcmis::ObjectTypePtr GDriveSession::getType( string id )
 {
     libcmis::ObjectTypePtr type( new GdriveObjectType( id ) );
diff --git a/src/libcmis/gdrive-session.hxx b/src/libcmis/gdrive-session.hxx
index f60ff6c..d29d454 100644
--- a/src/libcmis/gdrive-session.hxx
+++ b/src/libcmis/gdrive-session.hxx
@@ -55,10 +55,18 @@ class GDriveSession : public BaseSession
 
         virtual std::vector< libcmis::ObjectTypePtr > getBaseTypes( );
 
+        virtual libcmis::FolderPtr getRootFolder();
+
+        virtual std::string getRefreshToken();
+
     private:
         GDriveSession( );
         GDriveSession( const GDriveSession& copy ) = delete;
         GDriveSession& operator=( const GDriveSession& copy ) = delete;
+
+        virtual void setOAuth2Data( libcmis::OAuth2DataPtr oauth2 );
+
+        void oauth2Authenticate( );
 };
 
 #endif /* _GDRIVE_SESSION_HXX_ */
diff --git a/src/libcmis/gdrive-utils.cxx b/src/libcmis/gdrive-utils.cxx
index 6be2e43..3cc0288 100644
--- a/src/libcmis/gdrive-utils.cxx
+++ b/src/libcmis/gdrive-utils.cxx
@@ -44,17 +44,17 @@ string GdriveUtils::toCmisKey( const string& key )
         convertedKey = "cmis:createdBy";
     else if ( key == "description" )
         convertedKey = "cmis:description";
-    else if ( key == "createdDate" )
+    else if ( key == "createdTime" )
         convertedKey = "cmis:creationDate";
     else if ( key == "lastModifyingUserName" )
         convertedKey = "cmis:lastModifiedBy";
-    else if ( key == "modifiedDate" )
+    else if ( key == "modifiedTime" )
         convertedKey = "cmis:lastModificationDate";
-    else if ( key == "title" )
+    else if ( key == "name" )
         convertedKey = "cmis:contentStreamFileName";
     else if ( key == "mimeType" )
         convertedKey = "cmis:contentStreamMimeType";
-    else if ( key == "fileSize" )
+    else if ( key == "size" )
         convertedKey = "cmis:contentStreamLength";
     else if ( key == "editable" )
         convertedKey = "cmis:isImmutable";
@@ -72,21 +72,21 @@ string GdriveUtils::toGdriveKey( const string& key )
     else if ( key == "cmis:createdBy" )
         convertedKey = "ownerNames";
     else if ( key == "cmis:creationDate" )
-        convertedKey = "createdDate";
+        convertedKey = "createdTime";
     else if ( key == "cmis:description" )
         convertedKey = "description";
     else if ( key == "cmis:lastModifiedBy" )
         convertedKey = "lastModifyingUserName";
     else if ( key == "cmis:lastModificationDate" )
-        convertedKey = "modifiedDate";
+        convertedKey = "modifiedTime";
     else if ( key == "cmis:contentStreamFileName" )
-        convertedKey = "title";
+        convertedKey = "name";
     else if ( key == "cmis:name" )
-        convertedKey = "title";
+        convertedKey = "name";
     else if ( key == "cmis:contentStreamMimeType" )
         convertedKey = "mimeType";
     else if ( key == "cmis:contentStreamLength" )
-        convertedKey = "fileSize";
+        convertedKey = "size";
     else if ( key == "cmis:isImmutable" )
         convertedKey = "editable";
     else if ( key == "cmis:parentId" )
@@ -124,9 +124,9 @@ Json GdriveUtils::toGdriveJson( const PropertyPtrMap& properties )
 bool GdriveUtils::checkUpdatable( const string& key )
 {
     // taken from https://developers.google.com/drive/v2/reference/files
-    bool updatable = ( key == "title" ||
+    bool updatable = ( key == "name" ||
                   key == "description" ||
-                  key == "modifiedDate" ||
+                  key == "modifiedTime" ||
                   key == "lastViewedByMeDate" );
     return updatable;    
 }
@@ -143,18 +143,11 @@ bool GdriveUtils::checkMultiValued( const string& key )
 
 Json GdriveUtils::createJsonFromParentId( const string& parentId )
 {
-    Json parentValue( parentId.c_str( ) );
-    
     // parents is a Json array
     Json firstParent;
-    firstParent.add( "id", parentValue );
-    
-    Json::JsonVector parents;
-    parents.insert( parents.begin( ), firstParent );
+    firstParent.add( Json( parentId.c_str() ) );
     
-    Json parentsValue( parents );
-
-    return parentsValue;
+    return firstParent;
 }
 
 vector< string > GdriveUtils::parseGdriveProperty( string key, Json json )
diff --git a/src/libcmis/gdrive-utils.hxx b/src/libcmis/gdrive-utils.hxx
index 6f1c257..06ad568 100644
--- a/src/libcmis/gdrive-utils.hxx
+++ b/src/libcmis/gdrive-utils.hxx
@@ -35,7 +35,8 @@
 #include "json-utils.hxx"
 
 static const std::string GDRIVE_FOLDER_MIME_TYPE = "application/vnd.google-apps.folder" ;
-static const std::string GDRIVE_UPLOAD_LINKS = "https://www.googleapis.com/upload/drive/v2/files/";
+static const std::string GDRIVE_UPLOAD_LINK = "https://www.googleapis.com/upload/drive/v3/files/";
+static const std::string GDRIVE_METADATA_LINK = "https://www.googleapis.com/drive/v3/files/";
 
 class GdriveUtils
 {
diff --git a/src/libcmis/http-session.hxx b/src/libcmis/http-session.hxx
index 29de64d..6c9ed1b 100644
--- a/src/libcmis/http-session.hxx
+++ b/src/libcmis/http-session.hxx
@@ -148,7 +148,7 @@ class HttpSession
 
         void setNoSSLCertificateCheck( bool noCheck );
 
-        std::string getRefreshToken( );
+        virtual std::string getRefreshToken( );
 
     protected:
         HttpSession( );
diff --git a/src/libcmis/oauth2-handler.cxx b/src/libcmis/oauth2-handler.cxx
index 842769f..d70628d 100644
--- a/src/libcmis/oauth2-handler.cxx
+++ b/src/libcmis/oauth2-handler.cxx
@@ -92,8 +92,11 @@ void OAuth2Handler::fetchTokens( string authCode )
         "code="              + authCode +
         "&client_id="        + m_data->getClientId() +
         "&redirect_uri="     + m_data->getRedirectUri() +
-        "&scope="            + libcmis::escape( m_data->getScope() ) +
         "&grant_type=authorization_code" ;
+    if(boost::starts_with(m_data->getTokenUrl(), "https://oauth2.googleapis.com/"))
+        post += "&client_secret="    + m_data->getClientSecret();
+    else
+        post += "&scope="            + libcmis::escape( m_data->getScope() );
 
     istringstream is( post );
 
@@ -104,7 +107,7 @@ void OAuth2Handler::fetchTokens( string authCode )
         resp = m_session->httpPostRequest ( m_data->getTokenUrl(), is,
                                         "application/x-www-form-urlencoded" );
     }
-    catch ( const CurlException& )
+    catch ( const CurlException& e)
     {
         throw libcmis::Exception(
                 "Couldn't get tokens from the authorization code ");
@@ -122,6 +125,8 @@ void OAuth2Handler::refresh( )
         "refresh_token="     + m_refresh +
         "&client_id="        + m_data->getClientId() +
         "&grant_type=refresh_token" ;
+    if(boost::starts_with(m_data->getTokenUrl(), "https://oauth2.googleapis.com/"))
+        post += "&client_secret="    + m_data->getClientSecret();
 
     istringstream is( post );
     libcmis::HttpResponsePtr resp;
@@ -130,7 +135,7 @@ void OAuth2Handler::refresh( )
         resp = m_session->httpPostRequest( m_data->getTokenUrl( ), is,
                                            "application/x-www-form-urlencoded" );
     }
-    catch (const CurlException& )
+    catch (const CurlException& e )
     {
         throw libcmis::Exception( "Couldn't refresh token ");
     }
@@ -158,6 +163,11 @@ string OAuth2Handler::getRefreshToken( )
     return m_refresh;
 }
 
+void OAuth2Handler::setRefreshToken( string refreshToken )
+{
+    m_refresh = refreshToken;
+}
+
 string OAuth2Handler::getHttpHeader( )
 {
     string header;
diff --git a/src/libcmis/oauth2-handler.hxx b/src/libcmis/oauth2-handler.hxx
index 83e91cf..bb9a394 100644
--- a/src/libcmis/oauth2-handler.hxx
+++ b/src/libcmis/oauth2-handler.hxx
@@ -61,6 +61,7 @@ class OAuth2Handler
 
         std::string getAccessToken( ) ;
         std::string getRefreshToken( ) ;
+        void setRefreshToken( std::string refreshToken ) ;
 
         // adding HTTP auth header
         std::string getHttpHeader( ) ;
diff --git a/src/libcmis/oauth2-providers.cxx b/src/libcmis/oauth2-providers.cxx
index db6fbef..1c8d3cc 100644
--- a/src/libcmis/oauth2-providers.cxx
+++ b/src/libcmis/oauth2-providers.cxx
@@ -47,201 +47,8 @@
 
 using namespace std;
 
-namespace {
-
-// Encodes the given data according to the application/x-www-form-urlencoded format, see
-// <https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer>:
-std::string escapeForm(const std::string& data)
-{
-    std::string res;
-    for ( string::const_iterator i = data.begin(); i != data.end(); ++i )
-    {
-        unsigned char c = static_cast<unsigned char>( *i );
-        if ( c == ' ' || c == '*' || c == '-' || c == '.' || ( c >= '0' && c <= '9' )
-             || ( c >= 'A' && c <= 'Z' ) || c == '_' || ( c >= 'a' && c <= 'z' ) )
-        {
-            res += static_cast<char>( c );
-        }
-        else
-        {
-            static const char hex[16] = { '0', '1', '2', '3', '4', '5', '6', '7',
-                                          '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-            res += '%';
-            res += hex[c >> 4];
-            res += hex[c & 0xF];
-        }
-    }
-    return res;
-}
-
-}
-
-string OAuth2Providers::OAuth2Gdrive( HttpSession* session, const string& authUrl,
-                                      const string& username, const string& password )
-{
-    /* This member function implements 'Google OAuth 2.0'
-     *
-     * The interaction is carried out by libcmis, with no web browser involved.
-     *
-     * Normal sequence (without 2FA) is:
-     * 1) a get to activate login page
-     *    receive first login page, html format
-     * 2) subsequent post to sent email
-     *    receive html page for password input
-     * 3) subsequent post to send password
-     *    receive html page for application consent
-     * 4) subsequent post to send a consent for the application
-     *    receive a single-use authorization code
-     *    this code is returned as a string
-     *
-     * Sequence with 2FA is:
-     * 1) a get to activate login page
-     *    receive first login page, html format
-     * 2) subsequent post to sent email
-     *    receive html page for password input
-     * 3) subsequent post to send password
-     *    receive html page for pin input
-     * 3b) subsequent post to send pin number
-     *    receive html page for application consent
-     * 4) subsequent post to send a consent for the application
-     *    receive a single-use authorization code
-     *    this code is returned as a string
-     */
-
-    static const string CONTENT_TYPE( "application/x-www-form-urlencoded" );
-    // STEP 1: get login page
-    string res;
-    try
-    {
-        // send the first get, receive the html login page
-        res = session->httpGetRequest( authUrl )->getStream( )->str( );
-    }
-    catch ( const CurlException& )
-    {
-        return string( );
-    }
-
-    // STEP 2: send email
-
-    string loginEmailPost, loginEmailLink;
-    if ( !parseResponse( res.c_str( ), loginEmailPost, loginEmailLink ) )
-        return string( );
-
-    loginEmailPost += "Email=";
-    loginEmailPost += escapeForm( username );
-
-    istringstream loginEmailIs( loginEmailPost );
-    string loginEmailRes;
-    try
-    {
-        // send a post with user email, receive the html page for password input
-        loginEmailRes = session->httpPostRequest ( loginEmailLink, loginEmailIs, CONTENT_TYPE )
-                        ->getStream( )->str( );
-    }
-    catch ( const CurlException& )
-    {
-        return string( );
-    }
-
-    // STEP 3: password page
-
-    string loginPasswdPost, loginPasswdLink;
-    if ( !parseResponse( loginEmailRes.c_str( ), loginPasswdPost, loginPasswdLink ) )
-        return string( );
-
-    loginPasswdPost += "Passwd=";
-    loginPasswdPost += escapeForm( password );
-
-    istringstream loginPasswdIs( loginPasswdPost );
-    string loginPasswdRes;
-    try
-    {
-        // send a post with user password, receive the application consent page
-        loginPasswdRes = session->httpPostRequest ( loginPasswdLink, loginPasswdIs, CONTENT_TYPE )
-                        ->getStream( )->str( );
-    }
-    catch ( const CurlException& )
-    {
-        return string( );
-    }
-
-    string approvalPost, approvalLink;
-    if ( !parseResponse( loginPasswdRes. c_str( ), approvalPost, approvalLink) )
-        return string( );
-
-    // when 2FA is enabled, link doesn't start with 'http'
-    if ( approvalLink.compare(0, 4, "http") != 0 )
-    {
-        // STEP 3b: 2 Factor Authentication, pin code request
-
-        string loginChallengePost( approvalPost );
-        string loginChallengeLink( approvalLink );
-
-        libcmis::OAuth2AuthCodeProvider fallbackProvider = libcmis::SessionFactory::getOAuth2AuthCodeProvider( );
-        unique_ptr< char, void (*)( void * ) > pin{ fallbackProvider( "", "", "" ), free };
-
-        if( !pin )
-        {
-            // unset OAuth2AuthCode Provider to avoid showing pin request again in the HttpSession::oauth2Authenticate
-            libcmis::SessionFactory::setOAuth2AuthCodeProvider( NULL );
-            return string( );
-        }
-
-        loginChallengeLink = "https://accounts.google.com" + loginChallengeLink;
-        loginChallengePost += string( PIN_INPUT_NAME ) + "=";
-        loginChallengePost += string( pin.get() );
-
-        istringstream loginChallengeIs( loginChallengePost );
-        string loginChallengeRes;
-        try
-        {
-            // send a post with pin, receive the application consent page
-            loginChallengeRes = session->httpPostRequest ( loginChallengeLink, loginChallengeIs, CONTENT_TYPE )
-                            ->getStream( )->str( );
-        }
-        catch ( const CurlException& )
-        {
-            return string( );
-        }
-
-        approvalPost = string();
-        approvalLink = string();
-
-        if ( !parseResponse( loginChallengeRes. c_str( ), approvalPost, approvalLink) )
-            return string( );
-    }
-    else if( approvalLink.compare( "https://accounts.google.com/ServiceLoginAuth" ) == 0 )
-    {
-        // wrong password,
-        // unset OAuth2AuthCode Provider to avoid showing pin request again in the HttpSession::oauth2Authenticate
-        libcmis::SessionFactory::setOAuth2AuthCodeProvider( NULL );
-        return string( );
-    }
-
-    // STEP 4: allow libcmis to access google drive
-    approvalPost += "submit_access=true";
-
-    istringstream approvalIs( approvalPost );
-    string approvalRes;
-    try
-    {
-        // send a post with application consent
-        approvalRes = session->httpPostRequest ( approvalLink, approvalIs,
-                            CONTENT_TYPE) ->getStream( )->str( );
-    }
-    catch ( const CurlException& e )
-    {
-        throw e.getCmisException( );
-    }
-
-    // Take the authentication code from the text bar
-    string code = parseCode( approvalRes.c_str( ) );
-
-    return code;
-}
-
-string OAuth2Providers::OAuth2Onedrive( HttpSession* /*session*/, const string& /*authUrl*/,
-                                      const string& /*username*/, const string& /*password*/ )
+string OAuth2Providers::OAuth2Dummy( HttpSession* /*session*/, const string& /*authUrl*/,
+                                     const string& /*username*/, const string& /*password*/ )
 {
     return string( );
 }
@@ -309,12 +116,8 @@ OAuth2Parser OAuth2Providers::getOAuth2Parser( const std::string& url )
         // For Alfresco in the cloud, only match the hostname as there can be several
         // binding URLs created with it.
         return OAuth2Alfresco;
-    else if ( boost::starts_with( url, "https://www.googleapis.com/drive/v2" ) )
-        return OAuth2Gdrive;
-    else if ( boost::starts_with( url, "https://graph.microsoft.com/v1.0" ) )
-        return OAuth2Onedrive;
 
-    return OAuth2Gdrive;
+    return OAuth2Dummy;
 }
 
 int OAuth2Providers::parseResponse ( const char* response, string& post, string& link )
diff --git a/src/libcmis/oauth2-providers.hxx b/src/libcmis/oauth2-providers.hxx
index 04dff53..eaeb1c4 100644
--- a/src/libcmis/oauth2-providers.hxx
+++ b/src/libcmis/oauth2-providers.hxx
@@ -39,12 +39,8 @@ typedef std::string ( *OAuth2Parser ) ( HttpSession* session, const std::string&
 class OAuth2Providers
 {
     public :
-        static std::string OAuth2Gdrive( HttpSession* session, const std::string& authUrl, 
+        static std::string OAuth2Dummy( HttpSession* session, const std::string& authUrl,
                                        const std::string& username, const std::string& password );
-
-        static std::string OAuth2Onedrive( HttpSession* session, const std::string& authUrl, 
-                                       const std::string& username, const std::string& password );
-
         static std::string OAuth2Alfresco( HttpSession* session, const std::string& authUrl, 
                                        const std::string& username, const std::string& password );
 
diff --git a/src/libcmis/onedrive-session.cxx b/src/libcmis/onedrive-session.cxx
index 05ff45e..375cd2e 100644
--- a/src/libcmis/onedrive-session.cxx
+++ b/src/libcmis/onedrive-session.cxx
@@ -63,6 +63,45 @@ OneDriveSession::~OneDriveSession()
 {
 }
 
+void OneDriveSession::setOAuth2Data( libcmis::OAuth2DataPtr oauth2 )
+{
+    m_oauth2Handler = new OAuth2Handler( this, oauth2 );
+    m_oauth2Handler->setOAuth2Parser( OAuth2Providers::getOAuth2Parser( getBindingUrl( ) ) );
+
+    oauth2Authenticate( );
+}
+
+void OneDriveSession::oauth2Authenticate()
+{
+    // treat the supplied password as refresh token
+    if (!m_password.empty())
+    {
+        try
+        {
+            m_inOAuth2Authentication = true;
+
+            m_oauth2Handler->setRefreshToken(m_password);
+            // Try to get new access tokens using the stored refreshtoken
+            m_oauth2Handler->refresh();
+            m_inOAuth2Authentication = false;
+        }
+        catch (const CurlException &e)
+        {
+            m_inOAuth2Authentication = false;
+            // refresh token expired or invalid, trigger initial auth (that in turn will hit the fallback with copy'n'paste method)
+            BaseSession::oauth2Authenticate();
+        }
+    }
+    else
+    {
+        BaseSession::oauth2Authenticate();
+    }
+}
+
+string OneDriveSession::getRefreshToken() {
+    return HttpSession::getRefreshToken();
+}
+
 libcmis::RepositoryPtr OneDriveSession::getRepository( )
 {
     // Return a dummy repository since OneDrive doesn't have that notion
diff --git a/src/libcmis/onedrive-session.hxx b/src/libcmis/onedrive-session.hxx
index f11fbaf..3c30c04 100644
--- a/src/libcmis/onedrive-session.hxx
+++ b/src/libcmis/onedrive-session.hxx
@@ -56,14 +56,20 @@ class OneDriveSession : public BaseSession
         
         virtual std::vector< libcmis::ObjectTypePtr > getBaseTypes( );
 
-       libcmis::ObjectPtr getObjectFromJson( Json& jsonRes );
+        libcmis::ObjectPtr getObjectFromJson( Json& jsonRes );
 
-       bool isAPathMatch( Json objectJson, std::string path );
+        bool isAPathMatch( Json objectJson, std::string path );
+
+        virtual std::string getRefreshToken();
 
     private:
         OneDriveSession( );
         OneDriveSession( const OneDriveSession& copy ) = delete;
         OneDriveSession& operator=( const OneDriveSession& copy ) = delete;
+
+        virtual void setOAuth2Data( libcmis::OAuth2DataPtr oauth2 );
+
+        void oauth2Authenticate( );
 };
 
 #endif /* _ONEDRIVE_SESSION_HXX_ */
diff --git a/src/libcmis/session-factory.cxx b/src/libcmis/session-factory.cxx
index e740afb..1222473 100644
--- a/src/libcmis/session-factory.cxx
+++ b/src/libcmis/session-factory.cxx
@@ -66,7 +66,7 @@ namespace libcmis
         if ( !bindingUrl.empty( ) )
         {
             // Try the special cases based on the binding URL
-            if ( bindingUrl == "https://www.googleapis.com/drive/v2" )
+            if ( bindingUrl == "https://www.googleapis.com/drive/v3" )
             {
                 session = new GDriveSession( bindingUrl, username, password,
                                              oauth2, verbose );
