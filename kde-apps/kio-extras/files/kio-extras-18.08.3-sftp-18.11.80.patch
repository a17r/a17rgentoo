From 44e800dc1c15a374168b262a87ff4da3a57d1772 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Wed, 12 Sep 2018 17:17:11 +0200
Subject: [PATCH 01/22] [sftp] generate debug header at build time (this
 requires kf5.14)

Summary:
now use having boilerplate code sit around, pretty much the same stuff is
generated by ECM. KF 5.14 is ancient, so it should be good to require.

Reviewers: broulik

Reviewed By: broulik

Differential Revision: https://phabricator.kde.org/D15453
---
 CMakeLists.txt          |  1 +
 sftp/CMakeLists.txt     |  9 ++++++++-
 sftp/kio_sftp.cpp       |  2 +-
 sftp/kio_smtp_debug.cpp | 23 -----------------------
 sftp/kio_smtp_debug.h   | 27 ---------------------------
 5 files changed, 10 insertions(+), 52 deletions(-)
 delete mode 100644 sftp/kio_smtp_debug.cpp
 delete mode 100644 sftp/kio_smtp_debug.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9a152b1e..43498848 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -53,6 +53,7 @@ include(KDECompilerSettings NO_POLICY_SCOPE)
 include(ECMMarkNonGuiExecutable)
 include(ECMMarkAsTest)
 include(ECMOptionalAddSubdirectory)
+include(ECMQtDeclareLoggingCategory)
 
 add_definitions(-DQT_NO_URL_CAST_FROM_STRING)
 
diff --git a/sftp/CMakeLists.txt b/sftp/CMakeLists.txt
index 5e8d2cb1..c3252ff9 100644
--- a/sftp/CMakeLists.txt
+++ b/sftp/CMakeLists.txt
@@ -2,7 +2,14 @@ add_definitions(-DTRANSLATION_DOMAIN=\"kio5_sftp\")
 
 include_directories(${LIBSSH_INCLUDE_DIR})
 
-add_library(kio_sftp MODULE kio_sftp.cpp kio_smtp_debug.cpp)
+set(kio_sftp_SRCS kio_sftp.cpp)
+
+ecm_qt_declare_logging_category(kio_sftp_SRCS
+    HEADER kio_sftp_debug.h
+    IDENTIFIER KIO_SFTP_LOG
+    CATEGORY_NAME log_kio_sftp)
+
+add_library(kio_sftp MODULE ${kio_sftp_SRCS})
 target_link_libraries(kio_sftp
    KF5::KIOCore
    KF5::WidgetsAddons # KMessageBox
diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index e7a54856..bdd89ba8 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -22,7 +22,7 @@
 #include "kio_sftp.h"
 
 #include <config-runtime.h>
-#include "kio_smtp_debug.h"
+#include "kio_sftp_debug.h"
 #include <cerrno>
 #include <cstring>
 #include <utime.h>
diff --git a/sftp/kio_smtp_debug.cpp b/sftp/kio_smtp_debug.cpp
deleted file mode 100644
index 65703092..00000000
--- a/sftp/kio_smtp_debug.cpp
+++ /dev/null
@@ -1,23 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2014 Laurent Montel <montel@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#include "kio_smtp_debug.h"
-Q_LOGGING_CATEGORY(KIO_SFTP_LOG, "log_kio_sftp")
-
-
diff --git a/sftp/kio_smtp_debug.h b/sftp/kio_smtp_debug.h
deleted file mode 100644
index 4e91dc13..00000000
--- a/sftp/kio_smtp_debug.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*  This file is part of the KDE project
-    Copyright (C) 2014 Laurent Montel <montel@kde.org>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-*/
-
-#ifndef KIO_SMTP_DEBUG_H
-#define KIO_SMTP_DEBUG_H
-
-#include <QLoggingCategory>
-Q_DECLARE_LOGGING_CATEGORY(KIO_SFTP_LOG)
-
-#endif 
-
-- 
2.19.1


From 44eab3e9de1b451d34e100ed9fc67bf0eb2255e7 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Thu, 13 Sep 2018 10:47:19 +0200
Subject: [PATCH 02/22] [sftp] remove unused macros

Summary:
not used anywhere according to grep. slave still builds and works without
them.

Reviewers: broulik

Reviewed By: broulik

Differential Revision: https://phabricator.kde.org/D15470
---
 sftp/kio_sftp.cpp | 5 -----
 1 file changed, 5 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index bdd89ba8..0cd80df2 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -41,17 +41,12 @@
 #include <kconfiggroup.h>
 #include <kio/ioslave_defaults.h>
 
-
 #define KIO_SFTP_SPECIAL_TIMEOUT 30
 #define ZERO_STRUCTP(x) do { if ((x) != NULL) memset((char *)(x), 0, sizeof(*(x))); } while(0)
 
 // How big should each data packet be? Definitely not bigger than 64kb or
 // you will overflow the 2 byte size variable in a sftp packet.
 #define MAX_XFER_BUF_SIZE (60 * 1024)
-#define KIO_SFTP_DB 7120
-// Maximum amount of data which can be sent from the KIOSlave in one chunk
-// see TransferJob::slotDataReq (max_size variable) for the value
-#define MAX_TRANSFER_SIZE (14 * 1024 * 1024)
 
 using namespace KIO;
 extern "C"
-- 
2.19.1


From 0f92b54ca21a2c947a6e1ac365dbe9ec8aaec088 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Thu, 13 Sep 2018 11:20:20 +0200
Subject: [PATCH 03/22] [sftp] replace memset(0) hack with c++ initialization

Summary:
new T() in c++11 in a class with a default constructor that is not user
provided will zero initialize the object.
(see docs on `value initialization`)

Reviewers: broulik

Reviewed By: broulik

Differential Revision: https://phabricator.kde.org/D15472
---
 sftp/kio_sftp.cpp | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 0cd80df2..22530eb7 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -42,7 +42,6 @@
 #include <kio/ioslave_defaults.h>
 
 #define KIO_SFTP_SPECIAL_TIMEOUT 30
-#define ZERO_STRUCTP(x) do { if ((x) != NULL) memset((char *)(x), 0, sizeof(*(x))); } while(0)
 
 // How big should each data packet be? Definitely not bigger than 64kb or
 // you will overflow the 2 byte size variable in a sftp packet.
@@ -453,12 +452,12 @@ sftpProtocol::sftpProtocol(const QByteArray &pool_socket, const QByteArray &app_
   qCDebug(KIO_SFTP_LOG) << "debug = " << getenv("KIO_SFTP_LOG_VERBOSITY");
 #endif
 
-  mCallbacks = (ssh_callbacks) malloc(sizeof(struct ssh_callbacks_struct));
+  // Members are 'value initialized' to zero because of non-user defined ()!
+  mCallbacks = new struct ssh_callbacks_struct();
   if (mCallbacks == nullptr) {
     error(KIO::ERR_OUT_OF_MEMORY, i18n("Could not allocate callbacks"));
     return;
   }
-  ZERO_STRUCTP(mCallbacks);
 
   mCallbacks->userdata = this;
   mCallbacks->auth_function = ::auth_callback;
-- 
2.19.1


From a1458714bb0007ad8dba0d5d0d320b5ecf55e483 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Thu, 13 Sep 2018 14:11:56 +0200
Subject: [PATCH 04/22] [sftp] use qEnvironmentVariableIntValue instead of
 manual atoi checking

Summary: it's the Qt way of doing this

Reviewers: broulik

Reviewed By: broulik

Differential Revision: https://phabricator.kde.org/D15477
---
 sftp/kio_sftp.cpp | 11 ++++-------
 1 file changed, 4 insertions(+), 7 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 22530eb7..84f7aae9 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -464,12 +464,10 @@ sftpProtocol::sftpProtocol(const QByteArray &pool_socket, const QByteArray &app_
 
   ssh_callbacks_init(mCallbacks);
 
-  char *verbosity = getenv("KIO_SFTP_LOG_VERBOSITY");
-  if (verbosity != nullptr) {
-    int level = atoi(verbosity);
-    int rc;
-
-    rc = ssh_set_log_level(level);
+  bool ok;
+  int level = qEnvironmentVariableIntValue("KIO_SFTP_LOG_VERBOSITY", &ok);
+  if (ok) {
+    int rc = ssh_set_log_level(level);
     if (rc != SSH_OK) {
       error(KIO::ERR_INTERNAL, i18n("Could not set log verbosity."));
       return;
@@ -487,7 +485,6 @@ sftpProtocol::sftpProtocol(const QByteArray &pool_socket, const QByteArray &app_
       return;
     }
   }
-
 }
 
 sftpProtocol::~sftpProtocol() {
-- 
2.19.1


From 389c0d12994c25164a0a76b10c734afa86420765 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Thu, 13 Sep 2018 10:28:19 +0200
Subject: [PATCH 05/22] [sftp] treat all errors as errors

Summary:
certain libssh versions sometimes give out bogus errors. namely SSH_FX_OK
can sometimes be the current err even after a function returned with an
"something errord" return value. when converting these bogus errors
to KIO errors we'd sometimes end up reporting NoError when in fact there
was an error, we just don't know what it was because err is incorrect.
this ultimately resulted in KIO ending up in infinite loops because a job
neither errors nor correctly finishes

a scenario where this happens a lot is using dolphin to enter an sftp dir,
then deleting that dir on the CLI. dolphin would keep on querying
`sftpProtocol::fileSystemFreeSpace` which would run into server errors get
correctly reported by libssh 0.6 but 99% of the time err is SSH_FX_OK which
then locks KIO into an infinite loop of asking for freespace and getting
no answer but also no error. once this happens sftp will be broken from
a user's perspective as opening a new tab/dolphin will not work because
the slave is locked in this infinite loop.

to prevent this and similar issues we'll not let toKIOError ever return
NoError. toKIOError is only called after errors actually happend, so
NoError is not ever correct even when technically mapping the SSH err to
KIO would be NoError. for KIO we need a definitive result, and the
definitive result is always an error.

Reviewers: broulik

Reviewed By: broulik

Subscribers: leszeklesner

Differential Revision: https://phabricator.kde.org/D15454
---
 sftp/kio_sftp.cpp | 12 ++++++++----
 1 file changed, 8 insertions(+), 4 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 84f7aae9..7e30f662 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -70,12 +70,11 @@ extern "C"
   }
 }
 
-// Converts SSH error into KIO error
+// Converts SSH error into KIO error. Only must be called for error handling
+// as this will always return an error state and never NoError.
 static int toKIOError (const int err)
 {
   switch (err) {
-    case SSH_FX_OK:
-      break;
     case SSH_FX_NO_SUCH_FILE:
     case SSH_FX_NO_SUCH_PATH:
       return KIO::ERR_DOES_NOT_EXIST;
@@ -92,7 +91,12 @@ static int toKIOError (const int err)
     default:
       return KIO::ERR_INTERNAL;
   }
-  return 0;
+  // We should not get here. When this function gets called we've
+  // encountered an error on the libssh side, this needs to be mapped to *any*
+  // KIO error. Not mapping is not an option at this point, even if the ssh err
+  // is wrong or 'ok'.
+  Q_UNREACHABLE();
+  return KIO::ERR_UNKNOWN;
 }
 
 // Writes 'len' bytes from 'buf' to the file handle 'fd'.
-- 
2.19.1


From 2ff3b1903533975021697591f8fb56309751dc13 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Fri, 14 Sep 2018 11:51:11 +0200
Subject: [PATCH 06/22] [sftp] use UDSEntry::fastInsert instead of deprecated
 insert

Summary:
this bumps the requirement of kf5 to 5.48, by the time this gets released
(18.12) 5.48 should be sufficiently adopted out in the wild

Test Plan:
- looked at the code
- ran copy/read/write/list/refresh without problemos

Reviewers: broulik

Reviewed By: broulik

Differential Revision: https://phabricator.kde.org/D15499
---
 CMakeLists.txt    |  2 +-
 sftp/kio_sftp.cpp | 48 +++++++++++++++++++++++------------------------
 2 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 43498848..d503dfc4 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -10,7 +10,7 @@ project(kio-extras VERSION ${KDE_APPLICATIONS_VERSION})
 include(FeatureSummary)
 
 set(QT_MIN_VERSION "5.5.0")
-set(KF5_MIN_VERSION "5.40.0")
+set(KF5_MIN_VERSION "5.48.0")
 find_package(Qt5 ${QT_MIN_VERSION} CONFIG REQUIRED COMPONENTS DBus Network Widgets Svg)
 
 find_package(Qt5Test ${QT_MIN_VERSION} CONFIG QUIET)
diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 7e30f662..8b7dc06a 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -351,7 +351,7 @@ bool sftpProtocol::createUDSEntry(const QString &filename, const QByteArray &pat
     return false;
   }
 
-  entry.insert(KIO::UDSEntry::UDS_NAME, filename);
+  entry.fastInsert(KIO::UDSEntry::UDS_NAME, filename);
 
   if (sb->type == SSH_FILEXFER_TYPE_SYMLINK) {
     link = sftp_readlink(mSftp, path.constData());
@@ -359,7 +359,7 @@ bool sftpProtocol::createUDSEntry(const QString &filename, const QByteArray &pat
       sftp_attributes_free(sb);
       return false;
     }
-    entry.insert(KIO::UDSEntry::UDS_LINK_DEST, QFile::decodeName(link));
+    entry.fastInsert(KIO::UDSEntry::UDS_LINK_DEST, QFile::decodeName(link));
     free(link);
     // A symlink -> follow it only if details > 1
     if (details > 1) {
@@ -397,26 +397,26 @@ bool sftpProtocol::createUDSEntry(const QString &filename, const QByteArray &pat
     access = sb->permissions & 07777;
     size = sb->size;
   }
-  entry.insert(KIO::UDSEntry::UDS_FILE_TYPE, fileType);
-  entry.insert(KIO::UDSEntry::UDS_ACCESS, access);
-  entry.insert(KIO::UDSEntry::UDS_SIZE, size);
+  entry.fastInsert(KIO::UDSEntry::UDS_FILE_TYPE, fileType);
+  entry.fastInsert(KIO::UDSEntry::UDS_ACCESS, access);
+  entry.fastInsert(KIO::UDSEntry::UDS_SIZE, size);
 
   if (details > 0) {
     if (sb->owner) {
-      entry.insert(KIO::UDSEntry::UDS_USER, QString::fromUtf8(sb->owner));
+      entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::fromUtf8(sb->owner));
     } else {
-      entry.insert(KIO::UDSEntry::UDS_USER, QString::number(sb->uid));
+      entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::number(sb->uid));
     }
 
     if (sb->group) {
-      entry.insert(KIO::UDSEntry::UDS_GROUP, QString::fromUtf8(sb->group));
+      entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::fromUtf8(sb->group));
     } else {
-      entry.insert(KIO::UDSEntry::UDS_GROUP, QString::number(sb->gid));
+      entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::number(sb->gid));
     }
 
-    entry.insert(KIO::UDSEntry::UDS_ACCESS_TIME, sb->atime);
-    entry.insert(KIO::UDSEntry::UDS_MODIFICATION_TIME, sb->mtime);
-    entry.insert(KIO::UDSEntry::UDS_CREATION_TIME, sb->createtime);
+    entry.fastInsert(KIO::UDSEntry::UDS_ACCESS_TIME, sb->atime);
+    entry.fastInsert(KIO::UDSEntry::UDS_MODIFICATION_TIME, sb->mtime);
+    entry.fastInsert(KIO::UDSEntry::UDS_CREATION_TIME, sb->createtime);
   }
 
   sftp_attributes_free(sb);
@@ -1837,7 +1837,7 @@ void sftpProtocol::listDir(const QUrl& url) {
     }
 
     entry.clear();
-    entry.insert(KIO::UDSEntry::UDS_NAME, QFile::decodeName(dirent->name));
+    entry.fastInsert(KIO::UDSEntry::UDS_NAME, QFile::decodeName(dirent->name));
 
     if (dirent->type == SSH_FILEXFER_TYPE_SYMLINK) {
       QByteArray file = path + '/' + QFile::decodeName(dirent->name).toUtf8();
@@ -1848,7 +1848,7 @@ void sftpProtocol::listDir(const QUrl& url) {
         error(KIO::ERR_INTERNAL, i18n("Could not read link: %1", QString::fromUtf8(file)));
         return;
       }
-      entry.insert(KIO::UDSEntry::UDS_LINK_DEST, QFile::decodeName(link));
+      entry.fastInsert(KIO::UDSEntry::UDS_LINK_DEST, QFile::decodeName(link));
       free(link);
       // A symlink -> follow it only if details > 1
       if (details > 1) {
@@ -1886,26 +1886,26 @@ void sftpProtocol::listDir(const QUrl& url) {
       access = dirent->permissions & 07777;
       size = dirent->size;
     }
-    entry.insert(KIO::UDSEntry::UDS_FILE_TYPE, fileType);
-    entry.insert(KIO::UDSEntry::UDS_ACCESS, access);
-    entry.insert(KIO::UDSEntry::UDS_SIZE, size);
+    entry.fastInsert(KIO::UDSEntry::UDS_FILE_TYPE, fileType);
+    entry.fastInsert(KIO::UDSEntry::UDS_ACCESS, access);
+    entry.fastInsert(KIO::UDSEntry::UDS_SIZE, size);
 
     if (details > 0) {
       if (dirent->owner) {
-          entry.insert(KIO::UDSEntry::UDS_USER, QString::fromUtf8(dirent->owner));
+          entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::fromUtf8(dirent->owner));
       } else {
-          entry.insert(KIO::UDSEntry::UDS_USER, QString::number(dirent->uid));
+          entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::number(dirent->uid));
       }
 
       if (dirent->group) {
-          entry.insert(KIO::UDSEntry::UDS_GROUP, QString::fromUtf8(dirent->group));
+          entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::fromUtf8(dirent->group));
       } else {
-          entry.insert(KIO::UDSEntry::UDS_GROUP, QString::number(dirent->gid));
+          entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::number(dirent->gid));
       }
 
-      entry.insert(KIO::UDSEntry::UDS_ACCESS_TIME, dirent->atime);
-      entry.insert(KIO::UDSEntry::UDS_MODIFICATION_TIME, dirent->mtime);
-      entry.insert(KIO::UDSEntry::UDS_CREATION_TIME, dirent->createtime);
+      entry.fastInsert(KIO::UDSEntry::UDS_ACCESS_TIME, dirent->atime);
+      entry.fastInsert(KIO::UDSEntry::UDS_MODIFICATION_TIME, dirent->mtime);
+      entry.fastInsert(KIO::UDSEntry::UDS_CREATION_TIME, dirent->createtime);
     }
 
     sftp_attributes_free(dirent);
-- 
2.19.1


From 7f87598de70ae6bdb35bba1c27bb97ddab3d6daa Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Wed, 12 Sep 2018 16:58:04 +0200
Subject: [PATCH 07/22] [sftp] bump pending request count from 1 to 128

Summary:
with the previous value we basically did sync reading which means that
network and cyrptographic overhead head a huge impact on throughput.
meanwhile the perfect way to use asyncness is to schedule a whole bunch of
requests before starting to read.
previously this was documented as auto-adjusting, which it never was,
there's also little to be gained from adjusting this value on the fly.
more requests in most scenarios will simply mean a larger RAM footprint as
more data potentially sits in libssh waiting to be read. with 128 requests
that'd be ~8mb (assuming the file transferred is that large)

this improves read performance with libssh 0.8 by up to 20 times for large
files. read performance with libssh 0.6 is 2 to 3 times better.
the faster the connection the higher the gain of course.

128 gives somewhat competitive performance results compared to openssh's
ssh implementations while not having too large a footprint.

in raw numbers: a local link read was averaging around 10mb/s on both
libssh versions. with 128 requests this goes up to 200. competitive is
between 200 and 300 it seems (obviously all specific to my system)

CHANGELOG: sftp file reading is now up to 20 times faster

Reviewers: broulik

Reviewed By: broulik

Differential Revision: https://phabricator.kde.org/D15452
---
 sftp/kio_sftp.h | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/sftp/kio_sftp.h b/sftp/kio_sftp.h
index cc6b9e09..e5639970 100644
--- a/sftp/kio_sftp.h
+++ b/sftp/kio_sftp.h
@@ -141,10 +141,11 @@ private: // Private variables
      * @param file the sftp_file object which should be transferred.
      * @param sb the attributes of that sftp_file object.
      * @param maxPendingRequests the maximum number of parallel requests to start with.
-     *                            The number will be adjusted automatically depending
-     *                            on the connection speed.
+     *                           The more are pending the higher the potential memory
+     *                           foot print, however if the connection allows it
+     *                           we'll get better throughput.
      */
-    GetRequest(sftp_file file, sftp_attributes sb, ushort maxPendingRequests = 1);
+    GetRequest(sftp_file file, sftp_attributes sb, ushort maxPendingRequests = 128);
     /**
      * Removes all pending requests and closes the SFTP channel and attributes
      * in order to avoid memory leaks.
-- 
2.19.1


From 77d5a64b1fc662d2b753e6e7ed5c9b2f45bb89e0 Mon Sep 17 00:00:00 2001
From: Andreas Schneider <asn@cryptomilk.org>
Date: Sun, 2 Sep 2018 15:04:26 +0200
Subject: [PATCH 08/22] [sftp] Remove unused variable type

---
 sftp/kio_sftp.cpp | 2 --
 1 file changed, 2 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 8b7dc06a..a5b3fd6a 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -337,7 +337,6 @@ void sftpProtocol::reportError(const QUrl &url, const int err) {
 
 bool sftpProtocol::createUDSEntry(const QString &filename, const QByteArray &path,
       UDSEntry &entry, short int details) {
-  mode_t type;
   mode_t access;
   char *link;
   bool isBrokenLink = false;
@@ -1825,7 +1824,6 @@ void sftpProtocol::listDir(const QUrl& url) {
 
   for (;;) {
     mode_t access;
-    mode_t type;
     char *link;
     bool isBrokenLink = false;
     long long fileType = S_IFREG;
-- 
2.19.1


From a3179300345599d735f920bbe35bed81dc44039f Mon Sep 17 00:00:00 2001
From: Andreas Schneider <asn@cryptomilk.org>
Date: Sun, 2 Sep 2018 16:03:58 +0200
Subject: [PATCH 09/22] [sftp] Use TCP_NODELAY

typically improves performance
---
 sftp/kio_sftp.cpp | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index a5b3fd6a..1c6d85c9 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -542,6 +542,14 @@ bool sftpProtocol::sftpOpenConnection (const AuthInfo& info)
     return false;
   }
 
+  // Disable Nagle's Algorithm (TCP_NODELAY). Usually faster for sftp.
+  bool nodelay = true;
+  rc = ssh_options_set(mSession, SSH_OPTIONS_NODELAY, &nodelay);
+  if (rc < 0) {
+    error(KIO::ERR_INTERNAL, i18n("Could not disable Nagle's Algorithm."));
+    return false;
+  }
+
   // Don't use any compression
   rc = ssh_options_set(mSession, SSH_OPTIONS_COMPRESSION_C_S, "none");
   if (rc < 0) {
-- 
2.19.1


From 729e247a269ecb0e227d17dd51678ea224b5ff67 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Fri, 21 Sep 2018 14:34:27 +0200
Subject: [PATCH 10/22] [sftp] keep backwards compatible to < 0.8

0.8 is fairly new and may not be easily available for everyone
---
 sftp/kio_sftp.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 1c6d85c9..d59329d9 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -542,6 +542,7 @@ bool sftpProtocol::sftpOpenConnection (const AuthInfo& info)
     return false;
   }
 
+#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0, 8, 0)
   // Disable Nagle's Algorithm (TCP_NODELAY). Usually faster for sftp.
   bool nodelay = true;
   rc = ssh_options_set(mSession, SSH_OPTIONS_NODELAY, &nodelay);
@@ -549,6 +550,7 @@ bool sftpProtocol::sftpOpenConnection (const AuthInfo& info)
     error(KIO::ERR_INTERNAL, i18n("Could not disable Nagle's Algorithm."));
     return false;
   }
+#endif // 0.8.0
 
   // Don't use any compression
   rc = ssh_options_set(mSession, SSH_OPTIONS_COMPRESSION_C_S, "none");
-- 
2.19.1


From 8c14286a7b5642c986b5a7775374605cd574cfd3 Mon Sep 17 00:00:00 2001
From: Andreas Schneider <asn@cryptomilk.org>
Date: Sun, 2 Sep 2018 16:29:02 +0200
Subject: [PATCH 11/22] [sftp] always emit finished on completion

slaves should always emit an error or finished upon completion

applies to special, open, read, write, seek, get, put, copy, mkdir

(code slightly rejiggered by Harald Sitter <sitter@kde.org>)

CCBUG: 362988
---
 sftp/kio_sftp.cpp | 58 +++++++++++++++++++++++++----------------------
 1 file changed, 31 insertions(+), 27 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index d59329d9..48d8a3fe 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -942,8 +942,10 @@ void sftpProtocol::special(const QByteArray &) {
     int rc;
     qCDebug(KIO_SFTP_LOG) << "special(): polling";
 
-    if (!mSftp)
+    if (!mSftp) {
+        error(KIO::ERR_INTERNAL, i18n("Invalid sftp context"));
         return;
+    }
 
     /*
      * ssh_channel_poll() returns the number of bytes that may be read on the
@@ -968,6 +970,8 @@ void sftpProtocol::special(const QByteArray &) {
     }
 
     setTimeoutSpecialCommand(KIO_SFTP_SPECIAL_TIMEOUT);
+
+    finished();
 }
 
 void sftpProtocol::open(const QUrl &url, QIODevice::OpenMode mode) {
@@ -1064,6 +1068,7 @@ void sftpProtocol::open(const QUrl &url, QIODevice::OpenMode mode) {
   totalSize(fileSize);
   position(0);
   opened();
+  finished();
 }
 
 void sftpProtocol::read(KIO::filesize_t bytes) {
@@ -1085,6 +1090,7 @@ void sftpProtocol::read(KIO::filesize_t bytes) {
 
   const QByteArray fileData = QByteArray::fromRawData(buffer.data(), bytesRead);
   data(fileData);
+  finished();
 }
 
 void sftpProtocol::write(const QByteArray &data) {
@@ -1101,6 +1107,7 @@ void sftpProtocol::write(const QByteArray &data) {
   }
 
   written(bytesWritten);
+  finished();
 }
 
 void sftpProtocol::seek(KIO::filesize_t offset) {
@@ -1114,6 +1121,7 @@ void sftpProtocol::seek(KIO::filesize_t offset) {
   }
 
   position(sftp_tell64(mOpenFile));
+  finished();
 }
 
 void sftpProtocol::close() {
@@ -1129,16 +1137,14 @@ void sftpProtocol::get(const QUrl& url) {
   int errorCode = 0;
   const sftpProtocol::StatusCode cs = sftpGet(url, errorCode);
 
-  if (cs == sftpProtocol::Success) {
-    finished();
-    return;
-  }
-
   // The call to sftpGet should only return server side errors since the file
   // descriptor parameter is set to -1.
   if (cs == sftpProtocol::ServerError && errorCode) {
      error(errorCode, url.toDisplayString());
+     return;
   }
+
+  finished();
 }
 
 sftpProtocol::StatusCode sftpProtocol::sftpGet(const QUrl& url, int& errorCode, KIO::fileoffset_t offset, int fd) {
@@ -1278,16 +1284,14 @@ void sftpProtocol::put(const QUrl& url, int permissions, KIO::JobFlags flags) {
   int errorCode = 0;
   const sftpProtocol::StatusCode cs = sftpPut(url, permissions, flags, errorCode);
 
-  if (cs == sftpProtocol::Success) {
-    finished();
-    return;
-  }
-
   // The call to sftpPut should only return server side errors since the file
   // descriptor parameter is set to -1.
   if (cs == sftpProtocol::ServerError && errorCode) {
      error(errorCode, url.toDisplayString());
+     return;
   }
+
+  finished();
 }
 
 sftpProtocol::StatusCode sftpProtocol::sftpPut(const QUrl& url, int permissions, JobFlags flags, int& errorCode, int fd) {
@@ -1568,18 +1572,16 @@ void sftpProtocol::copy(const QUrl &src, const QUrl &dest, int permissions, KIO:
     sCopyFile.clear();
   }
 
-  // On success or errorcode < 0, emit the finished signal and
-  // send a warning message to the client if errorCode < 0.
-  if (cs == sftpProtocol::Success || errorCode < 0) {
-    if (errorCode < 0)
-      sftpSendWarning(errorCode, sCopyFile);
-    finished();
+  if (cs != sftpProtocol::Success && errorCode > 0) {
+    error(errorCode, sCopyFile);
     return;
   }
 
-  if (errorCode) {
-    error(errorCode, sCopyFile);
+  if (errorCode < 0) {
+    sftpSendWarning(errorCode, sCopyFile);
   }
+
+  finished();
 }
 
 sftpProtocol::StatusCode sftpProtocol::sftpCopyGet(const QUrl& url, const QString& sCopyFile, int permissions, KIO::JobFlags flags, int& errorCode)
@@ -1950,16 +1952,18 @@ void sftpProtocol::mkdir(const QUrl &url, int permissions) {
       reportError(url, sftp_get_error(mSftp));
       sftp_attributes_free(sb);
       return;
+    }
+
+    qCDebug(KIO_SFTP_LOG) << "Successfully created directory: " << url;
+    if (permissions != -1) {
+      // This will report an error or finished.
+      chmod(url, permissions);
     } else {
-      qCDebug(KIO_SFTP_LOG) << "Successfully created directory: " << url;
-      if (permissions != -1) {
-        chmod(url, permissions);
-      } else {
-        finished();
-      }
-      sftp_attributes_free(sb);
-      return;
+      finished();
     }
+
+    sftp_attributes_free(sb);
+    return;
   }
 
   if (sb->type == SSH_FILEXFER_TYPE_DIRECTORY) {
-- 
2.19.1


From bdd54664939944d90e812c74a984916abdf9346f Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Fri, 21 Sep 2018 14:08:13 +0200
Subject: [PATCH 12/22] [sftp] do not multi-finish on close calls

all frontend commands are now finishing, as a result commands calling
other commands would double finish or error-finish which constitutes soft
violations of slavebase expectations.
fix this by creating a specific close helper for internal use which
does not finish. this helper is now used by all commands and prevents
commands from double-finishing through close
---
 sftp/kio_sftp.cpp | 24 ++++++++++++++----------
 sftp/kio_sftp.h   |  3 +++
 2 files changed, 17 insertions(+), 10 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 48d8a3fe..ee490ad9 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -1049,7 +1049,7 @@ void sftpProtocol::open(const QUrl &url, QIODevice::OpenMode mode) {
     bytesRead = sftp_read(mOpenFile, buffer.data(), bytesRequested);
     if (bytesRead < 0) {
       error(KIO::ERR_COULD_NOT_READ, mOpenUrl.toDisplayString());
-      close();
+      closeWithoutFinish();
       return;
     } else {
       QByteArray fileData = QByteArray::fromRawData(buffer.data(), bytesRead);
@@ -1084,7 +1084,7 @@ void sftpProtocol::read(KIO::filesize_t bytes) {
   if (bytesRead < 0) {
     qCDebug(KIO_SFTP_LOG) << "Could not read " << mOpenUrl;
     error(KIO::ERR_COULD_NOT_READ, mOpenUrl.toDisplayString());
-    close();
+    closeWithoutFinish();
     return;
   }
 
@@ -1102,7 +1102,7 @@ void sftpProtocol::write(const QByteArray &data) {
   if (bytesWritten < 0) {
     qCDebug(KIO_SFTP_LOG) << "Could not write to " << mOpenUrl;
     error(KIO::ERR_COULD_NOT_WRITE, mOpenUrl.toDisplayString());
-    close();
+    closeWithoutFinish();
     return;
   }
 
@@ -1117,7 +1117,8 @@ void sftpProtocol::seek(KIO::filesize_t offset) {
 
   if (sftp_seek64(mOpenFile, static_cast<uint64_t>(offset)) < 0) {
     error(KIO::ERR_COULD_NOT_SEEK, mOpenUrl.path());
-    close();
+    closeWithoutFinish();
+    return;
   }
 
   position(sftp_tell64(mOpenFile));
@@ -1125,9 +1126,7 @@ void sftpProtocol::seek(KIO::filesize_t offset) {
 }
 
 void sftpProtocol::close() {
-  sftp_close(mOpenFile);
-
-  mOpenFile = nullptr;
+  closeWithoutFinish();
   finished();
 }
 
@@ -1783,9 +1782,8 @@ void sftpProtocol::mimetype(const QUrl& url){
 
   // open() feeds the mimetype
   open(url, QIODevice::ReadOnly);
-  close();
-
-  finished();
+  // open() finished(), don't finish in close again.
+  closeWithoutFinish();
 }
 
 void sftpProtocol::listDir(const QUrl& url) {
@@ -2263,6 +2261,12 @@ void sftpProtocol::sftpSendWarning(int errorCode, const QString& url)
   }
 }
 
+void sftpProtocol::closeWithoutFinish()
+{
+  sftp_close(mOpenFile);
+  mOpenFile = nullptr;
+}
+
 void sftpProtocol::clearPubKeyAuthInfo()
 {
   if (mPublicKeyAuthInfo) {
diff --git a/sftp/kio_sftp.h b/sftp/kio_sftp.h
index e5639970..590670ba 100644
--- a/sftp/kio_sftp.h
+++ b/sftp/kio_sftp.h
@@ -196,6 +196,9 @@ private: // private methods
   bool sftpOpenConnection(const KIO::AuthInfo&);
   void sftpSendWarning(int errorCode, const QString& url);
 
+  // Close without error() or finish() call (in case of errors for example)
+  void closeWithoutFinish();
+
   /**
     * Status Code returned from ftpPut() and ftpGet(), used to select
     * source or destination url for error messages
-- 
2.19.1


From 39c962e94f432b50345a5bac3d859f32bc52d25d Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Fri, 21 Sep 2018 14:09:12 +0200
Subject: [PATCH 13/22] [sftp] boilerplate comment that sftpLogin calls
 finished()

lest we call it again
---
 sftp/kio_sftp.cpp | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index ee490ad9..285cab0a 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -978,6 +978,7 @@ void sftpProtocol::open(const QUrl &url, QIODevice::OpenMode mode) {
   qCDebug(KIO_SFTP_LOG) << "open: " << url;
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
@@ -1729,6 +1730,7 @@ void sftpProtocol::stat(const QUrl& url) {
   qCDebug(KIO_SFTP_LOG) << url;
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
@@ -1777,6 +1779,7 @@ void sftpProtocol::mimetype(const QUrl& url){
   qCDebug(KIO_SFTP_LOG) << url;
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
@@ -1790,6 +1793,7 @@ void sftpProtocol::listDir(const QUrl& url) {
   qCDebug(KIO_SFTP_LOG) << "list directory: " << url;
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
@@ -1927,6 +1931,7 @@ void sftpProtocol::mkdir(const QUrl &url, int permissions) {
   qCDebug(KIO_SFTP_LOG) << "create directory: " << url;
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
@@ -1978,6 +1983,7 @@ void sftpProtocol::rename(const QUrl& src, const QUrl& dest, KIO::JobFlags flags
   qCDebug(KIO_SFTP_LOG) << "rename " << src << " to " << dest << flags;
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
@@ -2025,6 +2031,7 @@ void sftpProtocol::symlink(const QString &target, const QUrl &dest, KIO::JobFlag
                       << ", resume = " << (flags & KIO::Resume);
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
@@ -2062,6 +2069,7 @@ void sftpProtocol::chmod(const QUrl& url, int permissions) {
   qCDebug(KIO_SFTP_LOG) << "change permission of " << url << " to " << QString::number(permissions);
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
@@ -2079,6 +2087,7 @@ void sftpProtocol::del(const QUrl &url, bool isfile){
   qCDebug(KIO_SFTP_LOG) << "deleting " << (isfile ? "file: " : "directory: ") << url;
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
@@ -2280,6 +2289,7 @@ void sftpProtocol::fileSystemFreeSpace(const QUrl& url)
   qCDebug(KIO_SFTP_LOG) << "file system free space of" << url;
 
   if (!sftpLogin()) {
+    // sftpLogin finished()
     return;
   }
 
-- 
2.19.1


From 44d133229007a54f617f35339cb1996f52658a7b Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Fri, 21 Sep 2018 14:16:23 +0200
Subject: [PATCH 14/22] [sftp] simplify isDir handling

- new macro KSFTP_ISDIR akin to S_ISDIR checks if a given attributes is
  a directory
- ternary mutate dir||file error

this has the advantagous side effect of all commands now having an error()
or finished() call at the function end making it clear that we always
finished somehow
---
 sftp/kio_sftp.cpp | 26 ++++++++------------------
 1 file changed, 8 insertions(+), 18 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 285cab0a..03dccabd 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -47,6 +47,8 @@
 // you will overflow the 2 byte size variable in a sftp packet.
 #define MAX_XFER_BUF_SIZE (60 * 1024)
 
+#define KSFTP_ISDIR(sb) (sb->type == SSH_FILEXFER_TYPE_DIRECTORY)
+
 using namespace KIO;
 extern "C"
 {
@@ -1354,11 +1356,7 @@ sftpProtocol::StatusCode sftpProtocol::sftpPut(const QUrl& url, int permissions,
   }
 
   if (bOrigExists && !(flags & KIO::Overwrite) && !(flags & KIO::Resume)) {
-    if (sb->type == SSH_FILEXFER_TYPE_DIRECTORY) {
-      errorCode = KIO::ERR_DIR_ALREADY_EXIST;
-    } else {
-      errorCode = KIO::ERR_FILE_ALREADY_EXIST;
-    }
+    errorCode = KSFTP_ISDIR(sb) ? KIO::ERR_DIR_ALREADY_EXIST : KIO::ERR_FILE_ALREADY_EXIST;
     sftp_attributes_free(sb);
     return sftpProtocol::ServerError;
   }
@@ -1969,14 +1967,9 @@ void sftpProtocol::mkdir(const QUrl &url, int permissions) {
     return;
   }
 
-  if (sb->type == SSH_FILEXFER_TYPE_DIRECTORY) {
-    error(KIO::ERR_DIR_ALREADY_EXIST, path);
-  } else {
-    error(KIO::ERR_FILE_ALREADY_EXIST, path);
-  }
-
+  auto err = KSFTP_ISDIR(sb) ? KIO::ERR_DIR_ALREADY_EXIST : KIO::ERR_FILE_ALREADY_EXIST;
   sftp_attributes_free(sb);
-  return;
+  error(err, path);
 }
 
 void sftpProtocol::rename(const QUrl& src, const QUrl& dest, KIO::JobFlags flags) {
@@ -1992,18 +1985,15 @@ void sftpProtocol::rename(const QUrl& src, const QUrl& dest, KIO::JobFlags flags
 
   sftp_attributes sb = sftp_lstat(mSftp, qdest.constData());
   if (sb != nullptr) {
+    const bool isDir = KSFTP_ISDIR(sb);
     if (!(flags & KIO::Overwrite)) {
-      if (sb->type == SSH_FILEXFER_TYPE_DIRECTORY) {
-        error(KIO::ERR_DIR_ALREADY_EXIST, dest.url());
-      } else {
-        error(KIO::ERR_FILE_ALREADY_EXIST, dest.url());
-      }
+      error(isDir ? KIO::ERR_DIR_ALREADY_EXIST : KIO::ERR_FILE_ALREADY_EXIST, dest.url());
       sftp_attributes_free(sb);
       return;
     }
 
     // Delete the existing destination file/dir...
-    if (sb->type == SSH_FILEXFER_TYPE_DIRECTORY) {
+    if (isDir) {
       if (sftp_rmdir(mSftp, qdest.constData()) < 0) {
         reportError(dest, sftp_get_error(mSftp));
         return;
-- 
2.19.1


From 8deb978101bc0eaff276309c720254058f3993c1 Mon Sep 17 00:00:00 2001
From: Andreas Schneider <asn@cryptomilk.org>
Date: Sun, 2 Sep 2018 15:25:04 +0200
Subject: [PATCH 15/22] [cmake] Remove FindLibSSH.cmake

Since libssh version 0.7.x it ships with cmake config files, so there is
no need to keep this module.

Signed-off-by: Andreas Schneider <asn@cryptomilk.org>
---
 cmake/FindLibSSH.cmake | 101 -----------------------------------------
 1 file changed, 101 deletions(-)
 delete mode 100644 cmake/FindLibSSH.cmake

diff --git a/cmake/FindLibSSH.cmake b/cmake/FindLibSSH.cmake
deleted file mode 100644
index 0c918c62..00000000
--- a/cmake/FindLibSSH.cmake
+++ /dev/null
@@ -1,101 +0,0 @@
-# - Try to find LibSSH
-# Once done this will define
-#
-#  LIBSSH_FOUND - system has LibSSH
-#  LIBSSH_INCLUDE_DIRS - the LibSSH include directory
-#  LIBSSH_LIBRARIES - Link these to use LibSSH
-#  LIBSSH_DEFINITIONS - Compiler switches required for using LibSSH
-#
-#  Copyright (c) 2009-2014 Andreas Schneider <asn@cryptomilk.org>
-#
-# Redistribution and use in source and binary forms, with or without
-# modification, are permitted provided that the following conditions
-# are met:
-# 1. Redistributions of source code must retain the above copyright
-#    notice, this list of conditions and the following disclaimer.
-# 2. Redistributions in binary form must reproduce the above copyright
-#    notice, this list of conditions and the following disclaimer in the
-#    documentation and/or other materials provided with the distribution.
-# 3. Neither the name of the University nor the names of its contributors
-#    may be used to endorse or promote products derived from this software
-#    without specific prior written permission.
-#
-# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
-# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
-# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-# SUCH DAMAGE.
-
-find_path(LIBSSH_INCLUDE_DIR
-  NAMES
-    libssh/libssh.h
-  PATHS
-    /usr/include
-    /usr/local/include
-    /opt/local/include
-    /sw/include
-    ${CMAKE_INCLUDE_PATH}
-    ${CMAKE_INSTALL_PREFIX}/include
-)
-
-find_library(SSH_LIBRARY
-  NAMES
-    ssh
-    libssh
-  PATHS
-    /usr/lib
-    /usr/local/lib
-    /opt/local/lib
-    /sw/lib
-    ${CMAKE_LIBRARY_PATH}
-    ${CMAKE_INSTALL_PREFIX}/lib
-)
-
-set(LIBSSH_LIBRARIES
-    ${LIBSSH_LIBRARIES}
-    ${SSH_LIBRARY}
-)
-
-if (LIBSSH_INCLUDE_DIR AND LibSSH_FIND_VERSION)
-  file(STRINGS ${LIBSSH_INCLUDE_DIR}/libssh/libssh.h LIBSSH_VERSION_MAJOR
-    REGEX "#define[ ]+LIBSSH_VERSION_MAJOR[ ]+[0-9]+")
-
-  # Older versions of libssh like libssh-0.2 have LIBSSH_VERSION but not LIBSSH_VERSION_MAJOR
-  if (LIBSSH_VERSION_MAJOR)
-    string(REGEX MATCH "[0-9]+" LIBSSH_VERSION_MAJOR ${LIBSSH_VERSION_MAJOR})
-    file(STRINGS ${LIBSSH_INCLUDE_DIR}/libssh/libssh.h LIBSSH_VERSION_MINOR
-      REGEX "#define[ ]+LIBSSH_VERSION_MINOR[ ]+[0-9]+")
-    string(REGEX MATCH "[0-9]+" LIBSSH_VERSION_MINOR ${LIBSSH_VERSION_MINOR})
-    file(STRINGS ${LIBSSH_INCLUDE_DIR}/libssh/libssh.h LIBSSH_VERSION_PATCH
-      REGEX "#define[ ]+LIBSSH_VERSION_MICRO[ ]+[0-9]+")
-    string(REGEX MATCH "[0-9]+" LIBSSH_VERSION_PATCH ${LIBSSH_VERSION_PATCH})
-
-    set(LIBSSH_VERSION ${LIBSSH_VERSION_MAJOR}.${LIBSSH_VERSION_MINOR}.${LIBSSH_VERSION_PATCH})
-
-  else (LIBSSH_VERSION_MAJOR)
-    message(STATUS "LIBSSH_VERSION_MAJOR not found in ${LIBSSH_INCLUDE_DIR}/libssh/libssh.h, assuming libssh is too old")
-    set(LIBSSH_FOUND FALSE)
-  endif (LIBSSH_VERSION_MAJOR)
-endif (LIBSSH_INCLUDE_DIR AND LibSSH_FIND_VERSION)
-
-# If the version is too old, but libs and includes are set,
-# find_package_handle_standard_args will set LIBSSH_FOUND to TRUE again,
-# so we need this if() here.
-include(FindPackageHandleStandardArgs)
-find_package_handle_standard_args(LibSSH
-                                  FOUND_VAR
-                                    LIBSSH_FOUND
-                                  REQUIRED_VARS
-                                    LIBSSH_LIBRARIES
-                                    LIBSSH_INCLUDE_DIR
-                                  VERSION_VAR
-                                    LIBSSH_VERSION)
-
-# show the LIBSSH_INCLUDE_DIRS and LIBSSH_LIBRARIES variables only in the advanced view
-mark_as_advanced(LIBSSH_INCLUDE_DIR LIBSSH_LIBRARIES)
-- 
2.19.1


From 5a5cba1002afbf799379be2b2cad43ab5058ada0 Mon Sep 17 00:00:00 2001
From: Andreas Schneider <asn@cryptomilk.org>
Date: Sun, 2 Sep 2018 15:24:41 +0200
Subject: [PATCH 16/22] [cmake] Require libssh 0.7.0

Signed-off-by: Andreas Schneider <asn@cryptomilk.org>
---
 CMakeLists.txt | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index d503dfc4..590c922b 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -83,7 +83,7 @@ if(NOT WIN32)
                         )
 endif()
 
-find_package(LibSSH 0.6.0)
+find_package(libssh 0.7.0)
 set_package_properties(LibSSH PROPERTIES DESCRIPTION "the SSH library with SFTP support"
                        URL "http://www.libssh.org/"
                        TYPE OPTIONAL
@@ -157,7 +157,7 @@ if (NOT WIN32)
 endif()
 add_subdirectory( thumbnail )
 add_subdirectory( docfilter )
-if (NOT WIN32 AND LIBSSH_FOUND)
+if (LIBSSH_LIBRARY AND HAVE_UTIME_H)
     # does not compile on Windows: kio_sftp.cpp(28): fatal error C1083: Cannot open include file: 'utime.h': No such file or directory
     add_subdirectory(sftp)
 endif ()
-- 
2.19.1


From 8b98f5e2a3bb6903bdab582746321dd07542873b Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Tue, 23 Oct 2018 16:36:26 +0200
Subject: [PATCH 17/22] actually detect utime.h presence

(used in e0e72cac011cf8f4ed3561e7d42fea34499ac04d to enable sftp build)
---
 CMakeLists.txt | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 590c922b..7f8f9425 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -46,6 +46,7 @@ if (UNIX)
     find_package(KF5Pty ${KF5_MIN_VERSION} REQUIRED)
 endif()
 
+include(CheckIncludeFile)
 include(CMakePackageConfigHelpers)
 include(KDEInstallDirs)
 include(KDECMakeSettings)
@@ -97,6 +98,8 @@ set_package_properties(Mtp PROPERTIES DESCRIPTION "the MTP library"
                        PURPOSE "Needed to build the MTP kioslave"
                        )
 
+check_include_file(utime.h HAVE_UTIME_H)
+
 # ECM's KDECompilerSettings.cmake should take care of enabling supporting on
 # 32bit architectures.
 # Thorw a fatal error if off_t isn't >=64bit to ensure that large files are working
-- 
2.19.1


From 30f23a1987882a7da2944bfe06d8ad5a1370bf24 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Tue, 23 Oct 2018 15:57:04 +0200
Subject: [PATCH 18/22] [sftp] reformat to 4 space indentation

Summary:
while that generates history noise it's also much easier on the eyes and
something @asn wants to happen.

so, here we are

Test Plan: builds

Reviewers: asn, ngraham, apol

Reviewed By: ngraham, apol

Subscribers: asn, kde-frameworks-devel, kfm-devel, broulik

Tags: #dolphin, #frameworks

Differential Revision: https://phabricator.kde.org/D16385
---
 sftp/kio_sftp.cpp | 3440 ++++++++++++++++++++++-----------------------
 1 file changed, 1720 insertions(+), 1720 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 03dccabd..8b215011 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -52,16 +52,16 @@
 using namespace KIO;
 extern "C"
 {
-  int Q_DECL_EXPORT kdemain( int argc, char **argv )
-  {
+int Q_DECL_EXPORT kdemain( int argc, char **argv )
+{
     QCoreApplication app(argc, argv);
     app.setApplicationName("kio_sftp");
 
     qCDebug(KIO_SFTP_LOG) << "*** Starting kio_sftp ";
 
     if (argc != 4) {
-      qCDebug(KIO_SFTP_LOG) << "Usage: kio_sftp protocol domain-socket1 domain-socket2";
-      exit(-1);
+        qCDebug(KIO_SFTP_LOG) << "Usage: kio_sftp protocol domain-socket1 domain-socket2";
+        exit(-1);
     }
 
     sftpProtocol slave(argv[2], argv[3]);
@@ -69,63 +69,63 @@ extern "C"
 
     qCDebug(KIO_SFTP_LOG) << "*** kio_sftp Done";
     return 0;
-  }
+}
 }
 
 // Converts SSH error into KIO error. Only must be called for error handling
 // as this will always return an error state and never NoError.
 static int toKIOError (const int err)
 {
-  switch (err) {
+    switch (err) {
     case SSH_FX_NO_SUCH_FILE:
     case SSH_FX_NO_SUCH_PATH:
-      return KIO::ERR_DOES_NOT_EXIST;
+        return KIO::ERR_DOES_NOT_EXIST;
     case SSH_FX_PERMISSION_DENIED:
-      return KIO::ERR_ACCESS_DENIED;
+        return KIO::ERR_ACCESS_DENIED;
     case SSH_FX_FILE_ALREADY_EXISTS:
-      return KIO::ERR_FILE_ALREADY_EXIST;
+        return KIO::ERR_FILE_ALREADY_EXIST;
     case SSH_FX_INVALID_HANDLE:
-      return KIO::ERR_MALFORMED_URL;
+        return KIO::ERR_MALFORMED_URL;
     case SSH_FX_OP_UNSUPPORTED:
-      return KIO::ERR_UNSUPPORTED_ACTION;
+        return KIO::ERR_UNSUPPORTED_ACTION;
     case SSH_FX_BAD_MESSAGE:
-      return KIO::ERR_UNKNOWN;
+        return KIO::ERR_UNKNOWN;
     default:
-      return KIO::ERR_INTERNAL;
-  }
-  // We should not get here. When this function gets called we've
-  // encountered an error on the libssh side, this needs to be mapped to *any*
-  // KIO error. Not mapping is not an option at this point, even if the ssh err
-  // is wrong or 'ok'.
-  Q_UNREACHABLE();
-  return KIO::ERR_UNKNOWN;
+        return KIO::ERR_INTERNAL;
+    }
+    // We should not get here. When this function gets called we've
+    // encountered an error on the libssh side, this needs to be mapped to *any*
+    // KIO error. Not mapping is not an option at this point, even if the ssh err
+    // is wrong or 'ok'.
+    Q_UNREACHABLE();
+    return KIO::ERR_UNKNOWN;
 }
 
 // Writes 'len' bytes from 'buf' to the file handle 'fd'.
 static int writeToFile(int fd, const char *buf, size_t len)
 {
-  while (len > 0)  {
-      ssize_t written = write(fd, buf, len);
-
-      if (written >= 0) {
-        buf += written;
-        len -= written;
-        continue;
-      }
-
-      switch(errno) {
-      case EINTR:
-      case EAGAIN:
-        continue;
-      case EPIPE:
-        return ERR_CONNECTION_BROKEN;
-      case ENOSPC:
-        return ERR_DISK_FULL;
-      default:
-        return ERR_COULD_NOT_WRITE;
-      }
-  }
-  return 0;
+    while (len > 0)  {
+        ssize_t written = write(fd, buf, len);
+
+        if (written >= 0) {
+            buf += written;
+            len -= written;
+            continue;
+        }
+
+        switch(errno) {
+        case EINTR:
+        case EAGAIN:
+            continue;
+        case EPIPE:
+            return ERR_CONNECTION_BROKEN;
+        case ENOSPC:
+            return ERR_DISK_FULL;
+        default:
+            return ERR_COULD_NOT_WRITE;
+        }
+    }
+    return 0;
 }
 
 static int seekPos(int fd, KIO::fileoffset_t pos, int mode)
@@ -153,17 +153,17 @@ static bool wasUsernameChanged(const QString& username, const KIO::AuthInfo& inf
 static int auth_callback(const char *prompt, char *buf, size_t len,
                          int echo, int verify, void *userdata)
 {
-  if (userdata == nullptr) {
-    return -1;
-  }
+    if (userdata == nullptr) {
+        return -1;
+    }
 
-  sftpProtocol *slave = (sftpProtocol *) userdata;
+    sftpProtocol *slave = (sftpProtocol *) userdata;
 
-  if (slave->auth_callback(prompt, buf, len, echo, verify, userdata) < 0) {
-    return -1;
-  }
+    if (slave->auth_callback(prompt, buf, len, echo, verify, userdata) < 0) {
+        return -1;
+    }
 
-  return 0;
+    return 0;
 }
 
 static void log_callback(int priority, const char *function, const char *buffer,
@@ -179,50 +179,50 @@ static void log_callback(int priority, const char *function, const char *buffer,
 }
 
 int sftpProtocol::auth_callback(const char *prompt, char *buf, size_t len,
-    int echo, int verify, void *userdata) {
-
-  // unused variables
-  (void) echo;
-  (void) verify;
-  (void) userdata;
-
-  QString errMsg;
-  if (!mPublicKeyAuthInfo) {
-      mPublicKeyAuthInfo = new KIO::AuthInfo;
-  } else {
-      errMsg = i18n("Incorrect or invalid passphrase");
-  }
-
-  mPublicKeyAuthInfo->url.setScheme(QLatin1String("sftp"));
-  mPublicKeyAuthInfo->url.setHost(mHost);
-  if (mPort > 0 && mPort != DEFAULT_SFTP_PORT) {
-      mPublicKeyAuthInfo->url.setPort(mPort);
-  }
-  mPublicKeyAuthInfo->url.setUserName(mUsername);
-
-  QUrl u (mPublicKeyAuthInfo->url);
-  u.setPath(QString());
-  mPublicKeyAuthInfo->comment = u.url();
-  mPublicKeyAuthInfo->readOnly = true;
-  mPublicKeyAuthInfo->prompt = QString::fromUtf8(prompt);
-  mPublicKeyAuthInfo->keepPassword = false; // don't save passwords for public key,
-                            // that's the task of ssh-agent.
-  mPublicKeyAuthInfo->setExtraField(QLatin1String("hide-username-line"), true);
-  mPublicKeyAuthInfo->setModified(false);
-
-  qCDebug(KIO_SFTP_LOG) << "Entering authentication callback, prompt=" << mPublicKeyAuthInfo->prompt;
-
-  if (openPasswordDialogV2(*mPublicKeyAuthInfo, errMsg) != 0) {
-    qCDebug(KIO_SFTP_LOG) << "User canceled public key passpharse dialog";
-    return -1;
-  }
-
-  strncpy(buf, mPublicKeyAuthInfo->password.toUtf8().constData(), len - 1);
-
-  mPublicKeyAuthInfo->password.fill('x');
-  mPublicKeyAuthInfo->password.clear();
-
-  return 0;
+                                int echo, int verify, void *userdata) {
+
+    // unused variables
+    (void) echo;
+    (void) verify;
+    (void) userdata;
+
+    QString errMsg;
+    if (!mPublicKeyAuthInfo) {
+        mPublicKeyAuthInfo = new KIO::AuthInfo;
+    } else {
+        errMsg = i18n("Incorrect or invalid passphrase");
+    }
+
+    mPublicKeyAuthInfo->url.setScheme(QLatin1String("sftp"));
+    mPublicKeyAuthInfo->url.setHost(mHost);
+    if (mPort > 0 && mPort != DEFAULT_SFTP_PORT) {
+        mPublicKeyAuthInfo->url.setPort(mPort);
+    }
+    mPublicKeyAuthInfo->url.setUserName(mUsername);
+
+    QUrl u (mPublicKeyAuthInfo->url);
+    u.setPath(QString());
+    mPublicKeyAuthInfo->comment = u.url();
+    mPublicKeyAuthInfo->readOnly = true;
+    mPublicKeyAuthInfo->prompt = QString::fromUtf8(prompt);
+    mPublicKeyAuthInfo->keepPassword = false; // don't save passwords for public key,
+    // that's the task of ssh-agent.
+    mPublicKeyAuthInfo->setExtraField(QLatin1String("hide-username-line"), true);
+    mPublicKeyAuthInfo->setModified(false);
+
+    qCDebug(KIO_SFTP_LOG) << "Entering authentication callback, prompt=" << mPublicKeyAuthInfo->prompt;
+
+    if (openPasswordDialogV2(*mPublicKeyAuthInfo, errMsg) != 0) {
+        qCDebug(KIO_SFTP_LOG) << "User canceled public key passpharse dialog";
+        return -1;
+    }
+
+    strncpy(buf, mPublicKeyAuthInfo->password.toUtf8().constData(), len - 1);
+
+    mPublicKeyAuthInfo->password.fill('x');
+    mPublicKeyAuthInfo->password.clear();
+
+    return 0;
 }
 
 void sftpProtocol::log_callback(int priority, const char *function, const char *buffer,
@@ -235,709 +235,709 @@ void sftpProtocol::log_callback(int priority, const char *function, const char *
 
 void sftpProtocol::virtual_hook(int id, void *data)
 {
-  switch(id) {
-  case SlaveBase::GetFileSystemFreeSpace: {
-    QUrl *url = static_cast<QUrl *>(data);
-    fileSystemFreeSpace(*url);
-  } break;
-  default:
-    SlaveBase::virtual_hook(id, data);
-  }
+    switch(id) {
+    case SlaveBase::GetFileSystemFreeSpace: {
+        QUrl *url = static_cast<QUrl *>(data);
+        fileSystemFreeSpace(*url);
+    } break;
+    default:
+        SlaveBase::virtual_hook(id, data);
+    }
 }
 
 int sftpProtocol::authenticateKeyboardInteractive(AuthInfo &info) {
 
-  int err = ssh_userauth_kbdint(mSession, nullptr, nullptr);
+    int err = ssh_userauth_kbdint(mSession, nullptr, nullptr);
+
+    while (err == SSH_AUTH_INFO) {
+        const QString name = QString::fromUtf8(ssh_userauth_kbdint_getname(mSession));
+        const QString instruction = QString::fromUtf8(ssh_userauth_kbdint_getinstruction(mSession));
+        const int n = ssh_userauth_kbdint_getnprompts(mSession);
+
+        qCDebug(KIO_SFTP_LOG) << "name=" << name << " instruction=" << instruction << " prompts=" << n;
+
+        for (int i = 0; i < n; ++i) {
+            char echo;
+            const char *answer = "";
+
+            const QString prompt = QString::fromUtf8(ssh_userauth_kbdint_getprompt(mSession, i, &echo));
+            qCDebug(KIO_SFTP_LOG) << "prompt=" << prompt << " echo=" << QString::number(echo);
+            if (echo) {
+                // See RFC4256 Section 3.3 User Interface
+                KIO::AuthInfo infoKbdInt;
+
+                infoKbdInt.url.setScheme("sftp");
+                infoKbdInt.url.setHost(mHost);
+                if (mPort > 0 && mPort != DEFAULT_SFTP_PORT) {
+                    infoKbdInt.url.setPort(mPort);
+                }
+
+                if (!name.isEmpty()) {
+                    infoKbdInt.caption = QString(i18n("SFTP Login") + " - " + name);
+                } else {
+                    infoKbdInt.caption = i18n("SFTP Login");
+                }
+
+                infoKbdInt.comment = "sftp://" + mUsername + "@"  + mHost;
+
+                QString newPrompt;
+                if (!instruction.isEmpty()) {
+                    newPrompt = instruction + "<br /><br />";
+                }
+                newPrompt.append(prompt);
+                infoKbdInt.prompt = newPrompt;
+
+                infoKbdInt.readOnly = false;
+                infoKbdInt.keepPassword = false;
+
+                if (openPasswordDialogV2(infoKbdInt, i18n("Use the username input field to answer this question.")) == 0) {
+                    qCDebug(KIO_SFTP_LOG) << "Got the answer from the password dialog";
+                    answer = info.username.toUtf8().constData();
+                }
+
+                if (ssh_userauth_kbdint_setanswer(mSession, i, answer) < 0) {
+                    qCDebug(KIO_SFTP_LOG) << "An error occurred setting the answer: "
+                                          << ssh_get_error(mSession);
+                    return SSH_AUTH_ERROR;
+                }
+                break;
+            } else {
+                if (prompt.startsWith(QLatin1String("password:"), Qt::CaseInsensitive)) {
+                    info.prompt = i18n("Please enter your password.");
+                } else {
+                    info.prompt = prompt;
+                }
+                info.comment = info.url.url();
+                info.commentLabel = i18n("Site:");
+                info.setExtraField(QLatin1String("hide-username-line"), true);
+
+                if (openPasswordDialogV2(info) == 0) {
+                    qCDebug(KIO_SFTP_LOG) << "Got the answer from the password dialog";
+                    answer = info.password.toUtf8().constData();
+                }
+
+                if (ssh_userauth_kbdint_setanswer(mSession, i, answer) < 0) {
+                    qCDebug(KIO_SFTP_LOG) << "An error occurred setting the answer: "
+                                          << ssh_get_error(mSession);
+                    return SSH_AUTH_ERROR;
+                }
+            }
+        }
+        err = ssh_userauth_kbdint(mSession, nullptr, nullptr);
+    }
 
-  while (err == SSH_AUTH_INFO) {
-    const QString name = QString::fromUtf8(ssh_userauth_kbdint_getname(mSession));
-    const QString instruction = QString::fromUtf8(ssh_userauth_kbdint_getinstruction(mSession));
-    const int n = ssh_userauth_kbdint_getnprompts(mSession);
+    return err;
+}
 
-    qCDebug(KIO_SFTP_LOG) << "name=" << name << " instruction=" << instruction << " prompts=" << n;
+void sftpProtocol::reportError(const QUrl &url, const int err) {
+    qCDebug(KIO_SFTP_LOG) << "url = " << url << " - err=" << err;
 
-    for (int i = 0; i < n; ++i) {
-      char echo;
-      const char *answer = "";
+    const int kioError = toKIOError(err);
+    if (kioError)
+        error(kioError, url.toDisplayString());
+}
 
-      const QString prompt = QString::fromUtf8(ssh_userauth_kbdint_getprompt(mSession, i, &echo));
-      qCDebug(KIO_SFTP_LOG) << "prompt=" << prompt << " echo=" << QString::number(echo);
-      if (echo) {
-        // See RFC4256 Section 3.3 User Interface
-        KIO::AuthInfo infoKbdInt;
+bool sftpProtocol::createUDSEntry(const QString &filename, const QByteArray &path,
+                                  UDSEntry &entry, short int details) {
+    mode_t access;
+    char *link;
+    bool isBrokenLink = false;
+    long long fileType = S_IFREG;
+    long long size = 0LL;
 
-        infoKbdInt.url.setScheme("sftp");
-        infoKbdInt.url.setHost(mHost);
-        if (mPort > 0 && mPort != DEFAULT_SFTP_PORT) {
-            infoKbdInt.url.setPort(mPort);
-        }
+    Q_ASSERT(entry.count() == 0);
 
-        if (!name.isEmpty()) {
-          infoKbdInt.caption = QString(i18n("SFTP Login") + " - " + name);
-        } else {
-          infoKbdInt.caption = i18n("SFTP Login");
-        }
+    sftp_attributes sb = sftp_lstat(mSftp, path.constData());
+    if (sb == nullptr) {
+        return false;
+    }
 
-        infoKbdInt.comment = "sftp://" + mUsername + "@"  + mHost;
+    entry.fastInsert(KIO::UDSEntry::UDS_NAME, filename);
 
-        QString newPrompt;
-        if (!instruction.isEmpty()) {
-          newPrompt = instruction + "<br /><br />";
+    if (sb->type == SSH_FILEXFER_TYPE_SYMLINK) {
+        link = sftp_readlink(mSftp, path.constData());
+        if (link == nullptr) {
+            sftp_attributes_free(sb);
+            return false;
         }
-        newPrompt.append(prompt);
-        infoKbdInt.prompt = newPrompt;
-
-        infoKbdInt.readOnly = false;
-        infoKbdInt.keepPassword = false;
-
-        if (openPasswordDialogV2(infoKbdInt, i18n("Use the username input field to answer this question.")) == 0) {
-          qCDebug(KIO_SFTP_LOG) << "Got the answer from the password dialog";
-          answer = info.username.toUtf8().constData();
+        entry.fastInsert(KIO::UDSEntry::UDS_LINK_DEST, QFile::decodeName(link));
+        free(link);
+        // A symlink -> follow it only if details > 1
+        if (details > 1) {
+            sftp_attributes sb2 = sftp_stat(mSftp, path.constData());
+            if (sb2 == nullptr) {
+                isBrokenLink = true;
+            } else {
+                sftp_attributes_free(sb);
+                sb = sb2;
+            }
         }
+    }
 
-        if (ssh_userauth_kbdint_setanswer(mSession, i, answer) < 0) {
-          qCDebug(KIO_SFTP_LOG) << "An error occurred setting the answer: "
-            << ssh_get_error(mSession);
-          return SSH_AUTH_ERROR;
+    if (isBrokenLink) {
+        // It is a link pointing to nowhere
+        fileType = S_IFMT - 1;
+        access = S_IRWXU | S_IRWXG | S_IRWXO;
+        size = 0LL;
+    } else {
+        switch (sb->type) {
+        case SSH_FILEXFER_TYPE_REGULAR:
+            fileType = S_IFREG;
+            break;
+        case SSH_FILEXFER_TYPE_DIRECTORY:
+            fileType = S_IFDIR;
+            break;
+        case SSH_FILEXFER_TYPE_SYMLINK:
+            fileType = S_IFLNK;
+            break;
+        case SSH_FILEXFER_TYPE_SPECIAL:
+        case SSH_FILEXFER_TYPE_UNKNOWN:
+            fileType = S_IFMT - 1;
+            break;
         }
-        break;
-      } else {
-        if (prompt.startsWith(QLatin1String("password:"), Qt::CaseInsensitive)) {
-          info.prompt = i18n("Please enter your password.");
+        access = sb->permissions & 07777;
+        size = sb->size;
+    }
+    entry.fastInsert(KIO::UDSEntry::UDS_FILE_TYPE, fileType);
+    entry.fastInsert(KIO::UDSEntry::UDS_ACCESS, access);
+    entry.fastInsert(KIO::UDSEntry::UDS_SIZE, size);
+
+    if (details > 0) {
+        if (sb->owner) {
+            entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::fromUtf8(sb->owner));
         } else {
-          info.prompt = prompt;
+            entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::number(sb->uid));
         }
-        info.comment = info.url.url();
-        info.commentLabel = i18n("Site:");
-        info.setExtraField(QLatin1String("hide-username-line"), true);
 
-        if (openPasswordDialogV2(info) == 0) {
-          qCDebug(KIO_SFTP_LOG) << "Got the answer from the password dialog";
-          answer = info.password.toUtf8().constData();
+        if (sb->group) {
+            entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::fromUtf8(sb->group));
+        } else {
+            entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::number(sb->gid));
         }
 
-        if (ssh_userauth_kbdint_setanswer(mSession, i, answer) < 0) {
-          qCDebug(KIO_SFTP_LOG) << "An error occurred setting the answer: "
-            << ssh_get_error(mSession);
-          return SSH_AUTH_ERROR;
-        }
-      }
+        entry.fastInsert(KIO::UDSEntry::UDS_ACCESS_TIME, sb->atime);
+        entry.fastInsert(KIO::UDSEntry::UDS_MODIFICATION_TIME, sb->mtime);
+        entry.fastInsert(KIO::UDSEntry::UDS_CREATION_TIME, sb->createtime);
     }
-    err = ssh_userauth_kbdint(mSession, nullptr, nullptr);
-  }
-
-  return err;
-}
 
-void sftpProtocol::reportError(const QUrl &url, const int err) {
-  qCDebug(KIO_SFTP_LOG) << "url = " << url << " - err=" << err;
+    sftp_attributes_free(sb);
 
-  const int kioError = toKIOError(err);
-  if (kioError)
-      error(kioError, url.toDisplayString());
+    return true;
 }
 
-bool sftpProtocol::createUDSEntry(const QString &filename, const QByteArray &path,
-      UDSEntry &entry, short int details) {
-  mode_t access;
-  char *link;
-  bool isBrokenLink = false;
-  long long fileType = S_IFREG;
-  long long size = 0LL;
-
-  Q_ASSERT(entry.count() == 0);
-
-  sftp_attributes sb = sftp_lstat(mSftp, path.constData());
-  if (sb == nullptr) {
-    return false;
-  }
-
-  entry.fastInsert(KIO::UDSEntry::UDS_NAME, filename);
-
-  if (sb->type == SSH_FILEXFER_TYPE_SYMLINK) {
-    link = sftp_readlink(mSftp, path.constData());
-    if (link == nullptr) {
-      sftp_attributes_free(sb);
-      return false;
-    }
-    entry.fastInsert(KIO::UDSEntry::UDS_LINK_DEST, QFile::decodeName(link));
-    free(link);
-    // A symlink -> follow it only if details > 1
-    if (details > 1) {
-      sftp_attributes sb2 = sftp_stat(mSftp, path.constData());
-      if (sb2 == nullptr) {
-        isBrokenLink = true;
-      } else {
-         sftp_attributes_free(sb);
-         sb = sb2;
-      }
-    }
-  }
-
-  if (isBrokenLink) {
-    // It is a link pointing to nowhere
-    fileType = S_IFMT - 1;
-    access = S_IRWXU | S_IRWXG | S_IRWXO;
-    size = 0LL;
-  } else {
-    switch (sb->type) {
-      case SSH_FILEXFER_TYPE_REGULAR:
-        fileType = S_IFREG;
-        break;
-      case SSH_FILEXFER_TYPE_DIRECTORY:
-        fileType = S_IFDIR;
-        break;
-      case SSH_FILEXFER_TYPE_SYMLINK:
-        fileType = S_IFLNK;
-        break;
-      case SSH_FILEXFER_TYPE_SPECIAL:
-      case SSH_FILEXFER_TYPE_UNKNOWN:
-        fileType = S_IFMT - 1;
-        break;
-    }
-    access = sb->permissions & 07777;
-    size = sb->size;
-  }
-  entry.fastInsert(KIO::UDSEntry::UDS_FILE_TYPE, fileType);
-  entry.fastInsert(KIO::UDSEntry::UDS_ACCESS, access);
-  entry.fastInsert(KIO::UDSEntry::UDS_SIZE, size);
+QString sftpProtocol::canonicalizePath(const QString &path) {
+    qCDebug(KIO_SFTP_LOG) << "Path to canonicalize: " << path;
+    QString cPath;
+    char *sPath = nullptr;
 
-  if (details > 0) {
-    if (sb->owner) {
-      entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::fromUtf8(sb->owner));
-    } else {
-      entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::number(sb->uid));
+    if (path.isEmpty()) {
+        return cPath;
     }
 
-    if (sb->group) {
-      entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::fromUtf8(sb->group));
-    } else {
-      entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::number(sb->gid));
+    sPath = sftp_canonicalize_path(mSftp, path.toUtf8().constData());
+    if (sPath == nullptr) {
+        qCDebug(KIO_SFTP_LOG) << "Could not canonicalize path: " << path;
+        return cPath;
     }
 
-    entry.fastInsert(KIO::UDSEntry::UDS_ACCESS_TIME, sb->atime);
-    entry.fastInsert(KIO::UDSEntry::UDS_MODIFICATION_TIME, sb->mtime);
-    entry.fastInsert(KIO::UDSEntry::UDS_CREATION_TIME, sb->createtime);
-  }
-
-  sftp_attributes_free(sb);
-
-  return true;
-}
-
-QString sftpProtocol::canonicalizePath(const QString &path) {
-  qCDebug(KIO_SFTP_LOG) << "Path to canonicalize: " << path;
-  QString cPath;
-  char *sPath = nullptr;
+    cPath = QFile::decodeName(sPath);
+    delete sPath;
 
-  if (path.isEmpty()) {
-    return cPath;
-  }
+    qCDebug(KIO_SFTP_LOG) << "Canonicalized path: " << cPath;
 
-  sPath = sftp_canonicalize_path(mSftp, path.toUtf8().constData());
-  if (sPath == nullptr) {
-    qCDebug(KIO_SFTP_LOG) << "Could not canonicalize path: " << path;
     return cPath;
-  }
-
-  cPath = QFile::decodeName(sPath);
-  delete sPath;
-
-  qCDebug(KIO_SFTP_LOG) << "Canonicalized path: " << cPath;
-
-  return cPath;
 }
 
 sftpProtocol::sftpProtocol(const QByteArray &pool_socket, const QByteArray &app_socket)
-             : SlaveBase("kio_sftp", pool_socket, app_socket),
-               mConnected(false), mPort(-1), mSession(nullptr), mSftp(nullptr), mPublicKeyAuthInfo(nullptr) {
+    : SlaveBase("kio_sftp", pool_socket, app_socket),
+      mConnected(false), mPort(-1), mSession(nullptr), mSftp(nullptr), mPublicKeyAuthInfo(nullptr) {
 #ifndef Q_OS_WIN
-  qCDebug(KIO_SFTP_LOG) << "pid = " << getpid();
+    qCDebug(KIO_SFTP_LOG) << "pid = " << getpid();
 
-  qCDebug(KIO_SFTP_LOG) << "debug = " << getenv("KIO_SFTP_LOG_VERBOSITY");
+    qCDebug(KIO_SFTP_LOG) << "debug = " << getenv("KIO_SFTP_LOG_VERBOSITY");
 #endif
 
-  // Members are 'value initialized' to zero because of non-user defined ()!
-  mCallbacks = new struct ssh_callbacks_struct();
-  if (mCallbacks == nullptr) {
-    error(KIO::ERR_OUT_OF_MEMORY, i18n("Could not allocate callbacks"));
-    return;
-  }
+    // Members are 'value initialized' to zero because of non-user defined ()!
+    mCallbacks = new struct ssh_callbacks_struct();
+    if (mCallbacks == nullptr) {
+        error(KIO::ERR_OUT_OF_MEMORY, i18n("Could not allocate callbacks"));
+        return;
+    }
 
-  mCallbacks->userdata = this;
-  mCallbacks->auth_function = ::auth_callback;
+    mCallbacks->userdata = this;
+    mCallbacks->auth_function = ::auth_callback;
 
-  ssh_callbacks_init(mCallbacks);
+    ssh_callbacks_init(mCallbacks);
 
-  bool ok;
-  int level = qEnvironmentVariableIntValue("KIO_SFTP_LOG_VERBOSITY", &ok);
-  if (ok) {
-    int rc = ssh_set_log_level(level);
-    if (rc != SSH_OK) {
-      error(KIO::ERR_INTERNAL, i18n("Could not set log verbosity."));
-      return;
-    }
+    bool ok;
+    int level = qEnvironmentVariableIntValue("KIO_SFTP_LOG_VERBOSITY", &ok);
+    if (ok) {
+        int rc = ssh_set_log_level(level);
+        if (rc != SSH_OK) {
+            error(KIO::ERR_INTERNAL, i18n("Could not set log verbosity."));
+            return;
+        }
 
-    rc = ssh_set_log_userdata(this);
-    if (rc != SSH_OK) {
-      error(KIO::ERR_INTERNAL, i18n("Could not set log userdata."));
-      return;
-    }
+        rc = ssh_set_log_userdata(this);
+        if (rc != SSH_OK) {
+            error(KIO::ERR_INTERNAL, i18n("Could not set log userdata."));
+            return;
+        }
 
-    rc = ssh_set_log_callback(::log_callback);
-    if (rc != SSH_OK) {
-      error(KIO::ERR_INTERNAL, i18n("Could not set log callback."));
-      return;
+        rc = ssh_set_log_callback(::log_callback);
+        if (rc != SSH_OK) {
+            error(KIO::ERR_INTERNAL, i18n("Could not set log callback."));
+            return;
+        }
     }
-  }
 }
 
 sftpProtocol::~sftpProtocol() {
 #ifndef Q_OS_WIN
-  qCDebug(KIO_SFTP_LOG) << "pid = " << getpid();
+    qCDebug(KIO_SFTP_LOG) << "pid = " << getpid();
 #endif
-  closeConnection();
+    closeConnection();
 
-  delete mCallbacks;
-  delete mPublicKeyAuthInfo; // for precaution
+    delete mCallbacks;
+    delete mPublicKeyAuthInfo; // for precaution
 
-  /* cleanup and shut down cryto stuff */
-  ssh_finalize();
+    /* cleanup and shut down cryto stuff */
+    ssh_finalize();
 }
 
 void sftpProtocol::setHost(const QString& host, quint16 port, const QString& user, const QString& pass) {
-  qCDebug(KIO_SFTP_LOG) << user << "@" << host << ":" << port;
+    qCDebug(KIO_SFTP_LOG) << user << "@" << host << ":" << port;
 
-  // Close connection if the request is to another server...
-  if (host != mHost || port != mPort ||
-      user != mUsername || pass != mPassword) {
-    closeConnection();
-  }
+    // Close connection if the request is to another server...
+    if (host != mHost || port != mPort ||
+            user != mUsername || pass != mPassword) {
+        closeConnection();
+    }
 
-  mHost = host;
-  mPort = port;
-  mUsername = user;
-  mPassword = pass;
+    mHost = host;
+    mPort = port;
+    mUsername = user;
+    mPassword = pass;
 }
 
 bool sftpProtocol::sftpOpenConnection (const AuthInfo& info)
 {
-  mSession = ssh_new();
-  if (mSession == nullptr) {
-    error(KIO::ERR_OUT_OF_MEMORY, i18n("Could not create a new SSH session."));
-    return false;
-  }
-
-  long timeout_sec = 30, timeout_usec = 0;
-
-  qCDebug(KIO_SFTP_LOG) << "Creating the SSH session and setting options";
-
-  // Set timeout
-  int rc = ssh_options_set(mSession, SSH_OPTIONS_TIMEOUT, &timeout_sec);
-  if (rc < 0) {
-    error(KIO::ERR_INTERNAL, i18n("Could not set a timeout."));
-    return false;
-  }
-  rc = ssh_options_set(mSession, SSH_OPTIONS_TIMEOUT_USEC, &timeout_usec);
-  if (rc < 0) {
-    error(KIO::ERR_INTERNAL, i18n("Could not set a timeout."));
-    return false;
-  }
+    mSession = ssh_new();
+    if (mSession == nullptr) {
+        error(KIO::ERR_OUT_OF_MEMORY, i18n("Could not create a new SSH session."));
+        return false;
+    }
+
+    long timeout_sec = 30, timeout_usec = 0;
+
+    qCDebug(KIO_SFTP_LOG) << "Creating the SSH session and setting options";
+
+    // Set timeout
+    int rc = ssh_options_set(mSession, SSH_OPTIONS_TIMEOUT, &timeout_sec);
+    if (rc < 0) {
+        error(KIO::ERR_INTERNAL, i18n("Could not set a timeout."));
+        return false;
+    }
+    rc = ssh_options_set(mSession, SSH_OPTIONS_TIMEOUT_USEC, &timeout_usec);
+    if (rc < 0) {
+        error(KIO::ERR_INTERNAL, i18n("Could not set a timeout."));
+        return false;
+    }
 
 #if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0, 8, 0)
-  // Disable Nagle's Algorithm (TCP_NODELAY). Usually faster for sftp.
-  bool nodelay = true;
-  rc = ssh_options_set(mSession, SSH_OPTIONS_NODELAY, &nodelay);
-  if (rc < 0) {
-    error(KIO::ERR_INTERNAL, i18n("Could not disable Nagle's Algorithm."));
-    return false;
-  }
+    // Disable Nagle's Algorithm (TCP_NODELAY). Usually faster for sftp.
+    bool nodelay = true;
+    rc = ssh_options_set(mSession, SSH_OPTIONS_NODELAY, &nodelay);
+    if (rc < 0) {
+        error(KIO::ERR_INTERNAL, i18n("Could not disable Nagle's Algorithm."));
+        return false;
+    }
 #endif // 0.8.0
 
-  // Don't use any compression
-  rc = ssh_options_set(mSession, SSH_OPTIONS_COMPRESSION_C_S, "none");
-  if (rc < 0) {
-    error(KIO::ERR_INTERNAL, i18n("Could not set compression."));
-    return false;
-  }
-
-  rc = ssh_options_set(mSession, SSH_OPTIONS_COMPRESSION_S_C, "none");
-  if (rc < 0) {
-    error(KIO::ERR_INTERNAL, i18n("Could not set compression."));
-    return false;
-  }
-
-  // Set host and port
-  rc = ssh_options_set(mSession, SSH_OPTIONS_HOST, mHost.toUtf8().constData());
-  if (rc < 0) {
-    error(KIO::ERR_INTERNAL, i18n("Could not set host."));
-    return false;
-  }
-
-  if (mPort > 0) {
-    rc = ssh_options_set(mSession, SSH_OPTIONS_PORT, &mPort);
+    // Don't use any compression
+    rc = ssh_options_set(mSession, SSH_OPTIONS_COMPRESSION_C_S, "none");
+    if (rc < 0) {
+        error(KIO::ERR_INTERNAL, i18n("Could not set compression."));
+        return false;
+    }
+
+    rc = ssh_options_set(mSession, SSH_OPTIONS_COMPRESSION_S_C, "none");
     if (rc < 0) {
-        error(KIO::ERR_INTERNAL, i18n("Could not set port."));
-      return false;
+        error(KIO::ERR_INTERNAL, i18n("Could not set compression."));
+        return false;
     }
-  }
 
-  // Set the username
-  if (!info.username.isEmpty()) {
-    rc = ssh_options_set(mSession, SSH_OPTIONS_USER, info.username.toUtf8().constData());
+    // Set host and port
+    rc = ssh_options_set(mSession, SSH_OPTIONS_HOST, mHost.toUtf8().constData());
     if (rc < 0) {
-      error(KIO::ERR_INTERNAL, i18n("Could not set username."));
-      return false;
+        error(KIO::ERR_INTERNAL, i18n("Could not set host."));
+        return false;
+    }
+
+    if (mPort > 0) {
+        rc = ssh_options_set(mSession, SSH_OPTIONS_PORT, &mPort);
+        if (rc < 0) {
+            error(KIO::ERR_INTERNAL, i18n("Could not set port."));
+            return false;
+        }
+    }
+
+    // Set the username
+    if (!info.username.isEmpty()) {
+        rc = ssh_options_set(mSession, SSH_OPTIONS_USER, info.username.toUtf8().constData());
+        if (rc < 0) {
+            error(KIO::ERR_INTERNAL, i18n("Could not set username."));
+            return false;
+        }
     }
-  }
 
-  // Read ~/.ssh/config
-  rc = ssh_options_parse_config(mSession, nullptr);
-  if (rc < 0) {
-    error(KIO::ERR_INTERNAL, i18n("Could not parse the config file."));
-    return false;
-  }
+    // Read ~/.ssh/config
+    rc = ssh_options_parse_config(mSession, nullptr);
+    if (rc < 0) {
+        error(KIO::ERR_INTERNAL, i18n("Could not parse the config file."));
+        return false;
+    }
 
-  ssh_set_callbacks(mSession, mCallbacks);
+    ssh_set_callbacks(mSession, mCallbacks);
 
-  qCDebug(KIO_SFTP_LOG) << "Trying to connect to the SSH server";
+    qCDebug(KIO_SFTP_LOG) << "Trying to connect to the SSH server";
 
-  unsigned int effectivePort;
-  if (mPort > 0) {
-      effectivePort = mPort;
-  } else {
-      effectivePort = DEFAULT_SFTP_PORT;
-      ssh_options_get_port(mSession, &effectivePort);
-  }
+    unsigned int effectivePort;
+    if (mPort > 0) {
+        effectivePort = mPort;
+    } else {
+        effectivePort = DEFAULT_SFTP_PORT;
+        ssh_options_get_port(mSession, &effectivePort);
+    }
 
-  qCDebug(KIO_SFTP_LOG) << "username=" << mUsername << ", host=" << mHost << ", port=" << effectivePort;
+    qCDebug(KIO_SFTP_LOG) << "username=" << mUsername << ", host=" << mHost << ", port=" << effectivePort;
 
-  infoMessage(xi18n("Opening SFTP connection to host %1:%2", mHost, QString::number(effectivePort)));
+    infoMessage(xi18n("Opening SFTP connection to host %1:%2", mHost, QString::number(effectivePort)));
 
-  /* try to connect */
-  rc = ssh_connect(mSession);
-  if (rc < 0) {
-    error(KIO::ERR_SLAVE_DEFINED, QString::fromUtf8(ssh_get_error(mSession)));
-    closeConnection();
-    return false;
-  }
+    /* try to connect */
+    rc = ssh_connect(mSession);
+    if (rc < 0) {
+        error(KIO::ERR_SLAVE_DEFINED, QString::fromUtf8(ssh_get_error(mSession)));
+        closeConnection();
+        return false;
+    }
 
-  return true;
+    return true;
 }
 
 
 void sftpProtocol::openConnection() {
 
-  if (mConnected) {
-    return;
-  }
-
-  if (mHost.isEmpty()) {
-    qCDebug(KIO_SFTP_LOG) << "openConnection(): Need hostname...";
-    error(KIO::ERR_UNKNOWN_HOST, QString());
-    return;
-  }
-
-  AuthInfo info;
-  info.url.setScheme("sftp");
-  info.url.setHost(mHost);
-  if ( mPort > 0 && mPort != DEFAULT_SFTP_PORT ) {
-      info.url.setPort(mPort);
-  }
-  info.url.setUserName(mUsername);
-  info.username = mUsername;
-
-  // Check for cached authentication info if no password is specified...
-  if (mPassword.isEmpty()) {
-    qCDebug(KIO_SFTP_LOG) << "checking cache: info.username =" << info.username
-                        << ", info.url =" << info.url.toDisplayString();
-    checkCachedAuthentication(info);
-  } else {
-    info.password = mPassword;
-  }
-
-  // Start the ssh connection.
-  QString msg;     // msg for dialog box
-  QString caption; // dialog box caption
-  unsigned char *hash = nullptr; // the server hash
-  ssh_key srv_pubkey;
-  char *hexa;
-  size_t hlen;
-  int rc, state;
-
-  // Attempt to start a ssh session and establish a connection with the server.
-  if (!sftpOpenConnection(info)) {
-    return;
-  }
-
-  qCDebug(KIO_SFTP_LOG) << "Getting the SSH server hash";
-
-  /* get the hash */
-  rc = ssh_get_publickey(mSession, &srv_pubkey);
-  if (rc < 0) {
-    error(KIO::ERR_SLAVE_DEFINED, QString::fromUtf8(ssh_get_error(mSession)));
-    closeConnection();
-    return;
-  }
-
-  rc = ssh_get_publickey_hash(srv_pubkey,
-                              SSH_PUBLICKEY_HASH_SHA1,
-                              &hash,
-                              &hlen);
-  ssh_key_free(srv_pubkey);
-  if (rc < 0) {
-    error(KIO::ERR_SLAVE_DEFINED,
-          i18n("Could not create hash from server public key"));
-    closeConnection();
-    return;
-  }
+    if (mConnected) {
+        return;
+    }
+
+    if (mHost.isEmpty()) {
+        qCDebug(KIO_SFTP_LOG) << "openConnection(): Need hostname...";
+        error(KIO::ERR_UNKNOWN_HOST, QString());
+        return;
+    }
+
+    AuthInfo info;
+    info.url.setScheme("sftp");
+    info.url.setHost(mHost);
+    if ( mPort > 0 && mPort != DEFAULT_SFTP_PORT ) {
+        info.url.setPort(mPort);
+    }
+    info.url.setUserName(mUsername);
+    info.username = mUsername;
+
+    // Check for cached authentication info if no password is specified...
+    if (mPassword.isEmpty()) {
+        qCDebug(KIO_SFTP_LOG) << "checking cache: info.username =" << info.username
+                              << ", info.url =" << info.url.toDisplayString();
+        checkCachedAuthentication(info);
+    } else {
+        info.password = mPassword;
+    }
+
+    // Start the ssh connection.
+    QString msg;     // msg for dialog box
+    QString caption; // dialog box caption
+    unsigned char *hash = nullptr; // the server hash
+    ssh_key srv_pubkey;
+    char *hexa;
+    size_t hlen;
+    int rc, state;
+
+    // Attempt to start a ssh session and establish a connection with the server.
+    if (!sftpOpenConnection(info)) {
+        return;
+    }
+
+    qCDebug(KIO_SFTP_LOG) << "Getting the SSH server hash";
+
+    /* get the hash */
+    rc = ssh_get_publickey(mSession, &srv_pubkey);
+    if (rc < 0) {
+        error(KIO::ERR_SLAVE_DEFINED, QString::fromUtf8(ssh_get_error(mSession)));
+        closeConnection();
+        return;
+    }
 
-  qCDebug(KIO_SFTP_LOG) << "Checking if the SSH server is known";
+    rc = ssh_get_publickey_hash(srv_pubkey,
+                                SSH_PUBLICKEY_HASH_SHA1,
+                                &hash,
+                                &hlen);
+    ssh_key_free(srv_pubkey);
+    if (rc < 0) {
+        error(KIO::ERR_SLAVE_DEFINED,
+              i18n("Could not create hash from server public key"));
+        closeConnection();
+        return;
+    }
 
-  /* check the server public key hash */
-  state = ssh_is_server_known(mSession);
-  switch (state) {
+    qCDebug(KIO_SFTP_LOG) << "Checking if the SSH server is known";
+
+    /* check the server public key hash */
+    state = ssh_is_server_known(mSession);
+    switch (state) {
     case SSH_SERVER_KNOWN_OK:
-      break;
+        break;
     case SSH_SERVER_FOUND_OTHER:
-      ssh_string_free_char((char *)hash);
-      error(KIO::ERR_SLAVE_DEFINED, i18n("The host key for this server was "
-            "not found, but another type of key exists.\n"
-            "An attacker might change the default server key to confuse your "
-            "client into thinking the key does not exist.\n"
-            "Please contact your system administrator.\n%1", QString::fromUtf8(ssh_get_error(mSession))));
-      closeConnection();
-      return;
-    case SSH_SERVER_KNOWN_CHANGED:
-      hexa = ssh_get_hexa(hash, hlen);
-      ssh_string_free_char((char *)hash);
-      /* TODO print known_hosts file, port? */
-      error(KIO::ERR_SLAVE_DEFINED, i18n("The host key for the server %1 has changed.\n"
-          "This could either mean that DNS SPOOFING is happening or the IP "
-          "address for the host and its host key have changed at the same time.\n"
-          "The fingerprint for the key sent by the remote host is:\n %2\n"
-          "Please contact your system administrator.\n%3",
-          mHost, QString::fromUtf8(hexa), QString::fromUtf8(ssh_get_error(mSession))));
-      ssh_string_free_char(hexa);
-      closeConnection();
-      return;
-    case SSH_SERVER_FILE_NOT_FOUND:
-    case SSH_SERVER_NOT_KNOWN:
-      hexa = ssh_get_hexa(hash, hlen);
-      ssh_string_free_char((char *)hash);
-      caption = i18n("Warning: Cannot verify host's identity.");
-      msg = i18n("The authenticity of host %1 cannot be established.\n"
-        "The key fingerprint is: %2\n"
-        "Are you sure you want to continue connecting?", mHost, hexa);
-      ssh_string_free_char(hexa);
-
-      if (KMessageBox::Yes != messageBox(WarningYesNo, msg, caption)) {
+        ssh_string_free_char((char *)hash);
+        error(KIO::ERR_SLAVE_DEFINED, i18n("The host key for this server was "
+                                           "not found, but another type of key exists.\n"
+                                           "An attacker might change the default server key to confuse your "
+                                           "client into thinking the key does not exist.\n"
+                                           "Please contact your system administrator.\n%1", QString::fromUtf8(ssh_get_error(mSession))));
         closeConnection();
-        error(KIO::ERR_USER_CANCELED, QString());
         return;
-      }
-
-      /* write the known_hosts file */
-      qCDebug(KIO_SFTP_LOG) << "Adding server to known_hosts file.";
-      if (ssh_write_knownhost(mSession) < 0) {
-        error(KIO::ERR_USER_CANCELED, QString::fromUtf8(ssh_get_error(mSession)));
+    case SSH_SERVER_KNOWN_CHANGED:
+        hexa = ssh_get_hexa(hash, hlen);
+        ssh_string_free_char((char *)hash);
+        /* TODO print known_hosts file, port? */
+        error(KIO::ERR_SLAVE_DEFINED, i18n("The host key for the server %1 has changed.\n"
+                                           "This could either mean that DNS SPOOFING is happening or the IP "
+                                           "address for the host and its host key have changed at the same time.\n"
+                                           "The fingerprint for the key sent by the remote host is:\n %2\n"
+                                           "Please contact your system administrator.\n%3",
+                                           mHost, QString::fromUtf8(hexa), QString::fromUtf8(ssh_get_error(mSession))));
+        ssh_string_free_char(hexa);
         closeConnection();
         return;
-      }
-      break;
+    case SSH_SERVER_FILE_NOT_FOUND:
+    case SSH_SERVER_NOT_KNOWN:
+        hexa = ssh_get_hexa(hash, hlen);
+        ssh_string_free_char((char *)hash);
+        caption = i18n("Warning: Cannot verify host's identity.");
+        msg = i18n("The authenticity of host %1 cannot be established.\n"
+                   "The key fingerprint is: %2\n"
+                   "Are you sure you want to continue connecting?", mHost, hexa);
+        ssh_string_free_char(hexa);
+
+        if (KMessageBox::Yes != messageBox(WarningYesNo, msg, caption)) {
+            closeConnection();
+            error(KIO::ERR_USER_CANCELED, QString());
+            return;
+        }
+
+        /* write the known_hosts file */
+        qCDebug(KIO_SFTP_LOG) << "Adding server to known_hosts file.";
+        if (ssh_write_knownhost(mSession) < 0) {
+            error(KIO::ERR_USER_CANCELED, QString::fromUtf8(ssh_get_error(mSession)));
+            closeConnection();
+            return;
+        }
+        break;
     case SSH_SERVER_ERROR:
-      ssh_string_free_char((char *)hash);
-      error(KIO::ERR_SLAVE_DEFINED, QString::fromUtf8(ssh_get_error(mSession)));
-      return;
-  }
+        ssh_string_free_char((char *)hash);
+        error(KIO::ERR_SLAVE_DEFINED, QString::fromUtf8(ssh_get_error(mSession)));
+        return;
+    }
 
-  qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with the server";
+    qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with the server";
 
-  // Try to login without authentication
-  rc = ssh_userauth_none(mSession, nullptr);
-  if (rc == SSH_AUTH_ERROR) {
-    closeConnection();
-    error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
-    return;
-  }
-
-  // This NEEDS to be called after ssh_userauth_none() !!!
-  int method = ssh_auth_list(mSession);
-  if (rc != SSH_AUTH_SUCCESS && method == 0) {
-      closeConnection();
-      error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed. The server "
-            "didn't send any authentication methods"));
-      return;
-  }
-
-  // Try to authenticate with public key first
-  if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_PUBLICKEY)) {
-    qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with public key";
-    for(;;) {
-      rc = ssh_userauth_publickey_auto(mSession, nullptr, nullptr);
-      if (rc == SSH_AUTH_ERROR) {
-        qCDebug(KIO_SFTP_LOG) << "Public key authentication failed:" <<
-                QString::fromUtf8(ssh_get_error(mSession));
+    // Try to login without authentication
+    rc = ssh_userauth_none(mSession, nullptr);
+    if (rc == SSH_AUTH_ERROR) {
         closeConnection();
-        clearPubKeyAuthInfo();
         error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
         return;
-      } else if (rc != SSH_AUTH_DENIED || !mPublicKeyAuthInfo || !mPublicKeyAuthInfo->isModified()) {
-        clearPubKeyAuthInfo();
-        break;
-      }
-    }
-  }
-
-  // Try to authenticate with GSSAPI
-  if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_GSSAPI_MIC)) {
-      qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with GSSAPI";
-      rc = ssh_userauth_gssapi(mSession);
-      if (rc == SSH_AUTH_ERROR) {
-          qCDebug(KIO_SFTP_LOG) << "Public key authentication failed:" <<
-                 QString::fromUtf8(ssh_get_error(mSession));
-          closeConnection();
-          error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
-          return;
-      }
-  }
-
-  // Try to authenticate with keyboard interactive
-  if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_INTERACTIVE)) {
-    qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with keyboard interactive";
-    AuthInfo info2 (info);
-    rc = authenticateKeyboardInteractive(info2);
-    if (rc == SSH_AUTH_SUCCESS) {
-      info = info2;
-    } else if (rc == SSH_AUTH_ERROR) {
-      qCDebug(KIO_SFTP_LOG) << "Keyboard interactive authentication failed:"
-                          << QString::fromUtf8(ssh_get_error(mSession));
-      closeConnection();
-      error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
-      return;
-    }
-  }
-
-  // Try to authenticate with password
-  if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_PASSWORD)) {
-    qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with password";
-
-    info.caption = i18n("SFTP Login");
-    info.prompt = i18n("Please enter your username and password.");
-    info.comment = info.url.url();
-    info.commentLabel = i18n("Site:");
-    bool isFirstLoginAttempt = true;
-
-    for(;;) {
-      if (!isFirstLoginAttempt || info.password.isEmpty()) {
-        info.keepPassword = true; // make the "keep Password" check box visible to the user.
-        info.setModified(false);
-
-        QString username (info.username);
-        const QString errMsg(isFirstLoginAttempt ? QString() : i18n("Incorrect username or password"));
-
-        qCDebug(KIO_SFTP_LOG) << "Username:" << username << "first attempt?"
-                            << isFirstLoginAttempt << "error:" << errMsg;
-
-        // Handle user canceled or dialog failed to open...
-
-        int errCode = openPasswordDialogV2(info, errMsg);
-        if (errCode != 0) {
-          qCDebug(KIO_SFTP_LOG) << "User canceled password/retry dialog";
-          closeConnection();
-          error(errCode, QString());
-          return;
+    }
+
+    // This NEEDS to be called after ssh_userauth_none() !!!
+    int method = ssh_auth_list(mSession);
+    if (rc != SSH_AUTH_SUCCESS && method == 0) {
+        closeConnection();
+        error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed. The server "
+                                             "didn't send any authentication methods"));
+        return;
+    }
+
+    // Try to authenticate with public key first
+    if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_PUBLICKEY)) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with public key";
+        for(;;) {
+            rc = ssh_userauth_publickey_auto(mSession, nullptr, nullptr);
+            if (rc == SSH_AUTH_ERROR) {
+                qCDebug(KIO_SFTP_LOG) << "Public key authentication failed:" <<
+                                         QString::fromUtf8(ssh_get_error(mSession));
+                closeConnection();
+                clearPubKeyAuthInfo();
+                error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+                return;
+            } else if (rc != SSH_AUTH_DENIED || !mPublicKeyAuthInfo || !mPublicKeyAuthInfo->isModified()) {
+                clearPubKeyAuthInfo();
+                break;
+            }
         }
+    }
 
-        // If the user name changes, we have to restablish connection again
-        // since the user name must always be set before calling ssh_connect.
-        if (wasUsernameChanged(username, info)) {
-          qCDebug(KIO_SFTP_LOG) << "Username changed to" << info.username;
-          if (!info.url.userName().isEmpty()) {
-            info.url.setUserName(info.username);
-          }
-          closeConnection();
-          if (!sftpOpenConnection(info)) {
-              return;
-          }
+    // Try to authenticate with GSSAPI
+    if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_GSSAPI_MIC)) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with GSSAPI";
+        rc = ssh_userauth_gssapi(mSession);
+        if (rc == SSH_AUTH_ERROR) {
+            qCDebug(KIO_SFTP_LOG) << "Public key authentication failed:" <<
+                                     QString::fromUtf8(ssh_get_error(mSession));
+            closeConnection();
+            error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+            return;
         }
-      }
+    }
 
-      rc = ssh_userauth_password(mSession, info.username.toUtf8().constData(), info.password.toUtf8().constData());
-      if (rc == SSH_AUTH_SUCCESS) {
-        break;
-      } else if (rc == SSH_AUTH_ERROR) {
-        qCDebug(KIO_SFTP_LOG) << "Password authentication failed:"
-                            << QString::fromUtf8(ssh_get_error(mSession));
-        closeConnection();
+    // Try to authenticate with keyboard interactive
+    if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_INTERACTIVE)) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with keyboard interactive";
+        AuthInfo info2 (info);
+        rc = authenticateKeyboardInteractive(info2);
+        if (rc == SSH_AUTH_SUCCESS) {
+            info = info2;
+        } else if (rc == SSH_AUTH_ERROR) {
+            qCDebug(KIO_SFTP_LOG) << "Keyboard interactive authentication failed:"
+                                  << QString::fromUtf8(ssh_get_error(mSession));
+            closeConnection();
+            error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+            return;
+        }
+    }
+
+    // Try to authenticate with password
+    if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_PASSWORD)) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with password";
+
+        info.caption = i18n("SFTP Login");
+        info.prompt = i18n("Please enter your username and password.");
+        info.comment = info.url.url();
+        info.commentLabel = i18n("Site:");
+        bool isFirstLoginAttempt = true;
+
+        for(;;) {
+            if (!isFirstLoginAttempt || info.password.isEmpty()) {
+                info.keepPassword = true; // make the "keep Password" check box visible to the user.
+                info.setModified(false);
+
+                QString username (info.username);
+                const QString errMsg(isFirstLoginAttempt ? QString() : i18n("Incorrect username or password"));
+
+                qCDebug(KIO_SFTP_LOG) << "Username:" << username << "first attempt?"
+                                      << isFirstLoginAttempt << "error:" << errMsg;
+
+                // Handle user canceled or dialog failed to open...
+
+                int errCode = openPasswordDialogV2(info, errMsg);
+                if (errCode != 0) {
+                    qCDebug(KIO_SFTP_LOG) << "User canceled password/retry dialog";
+                    closeConnection();
+                    error(errCode, QString());
+                    return;
+                }
+
+                // If the user name changes, we have to restablish connection again
+                // since the user name must always be set before calling ssh_connect.
+                if (wasUsernameChanged(username, info)) {
+                    qCDebug(KIO_SFTP_LOG) << "Username changed to" << info.username;
+                    if (!info.url.userName().isEmpty()) {
+                        info.url.setUserName(info.username);
+                    }
+                    closeConnection();
+                    if (!sftpOpenConnection(info)) {
+                        return;
+                    }
+                }
+            }
+
+            rc = ssh_userauth_password(mSession, info.username.toUtf8().constData(), info.password.toUtf8().constData());
+            if (rc == SSH_AUTH_SUCCESS) {
+                break;
+            } else if (rc == SSH_AUTH_ERROR) {
+                qCDebug(KIO_SFTP_LOG) << "Password authentication failed:"
+                                      << QString::fromUtf8(ssh_get_error(mSession));
+                closeConnection();
+                error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+                return;
+            }
+
+            isFirstLoginAttempt = false; // failed attempt to login.
+            info.password.clear();       // clear the password after failed attempts.
+        }
+    }
+
+    // If we're still not authenticated then we need to leave.
+    if (rc != SSH_AUTH_SUCCESS) {
         error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
         return;
-      }
+    }
+
+    // start sftp session
+    qCDebug(KIO_SFTP_LOG) << "Trying to request the sftp session";
+    mSftp = sftp_new(mSession);
+    if (mSftp == nullptr) {
+        closeConnection();
+        error(KIO::ERR_COULD_NOT_LOGIN, i18n("Unable to request the SFTP subsystem. "
+                                             "Make sure SFTP is enabled on the server."));
+        return;
+    }
 
-      isFirstLoginAttempt = false; // failed attempt to login.
-      info.password.clear();       // clear the password after failed attempts.
+    qCDebug(KIO_SFTP_LOG) << "Trying to initialize the sftp session";
+    if (sftp_init(mSftp) < 0) {
+        closeConnection();
+        error(KIO::ERR_COULD_NOT_LOGIN, i18n("Could not initialize the SFTP session."));
+        return;
     }
-  }
 
-  // If we're still not authenticated then we need to leave.
-  if (rc != SSH_AUTH_SUCCESS) {
-    error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
-    return;
-  }
+    // Login succeeded!
+    infoMessage(i18n("Successfully connected to %1", mHost));
+    if (info.keepPassword) {
+        qCDebug(KIO_SFTP_LOG) << "Caching info.username = " << info.username
+                              << ", info.url = " << info.url.toDisplayString();
+        cacheAuthentication(info);
+    }
 
-  // start sftp session
-  qCDebug(KIO_SFTP_LOG) << "Trying to request the sftp session";
-  mSftp = sftp_new(mSession);
-  if (mSftp == nullptr) {
-    closeConnection();
-    error(KIO::ERR_COULD_NOT_LOGIN, i18n("Unable to request the SFTP subsystem. "
-          "Make sure SFTP is enabled on the server."));
-    return;
-  }
+    // Update the original username in case it was changed!
+    if (!mUsername.isEmpty()) {
+        mUsername = info.username;
+    }
 
-  qCDebug(KIO_SFTP_LOG) << "Trying to initialize the sftp session";
-  if (sftp_init(mSftp) < 0) {
-    closeConnection();
-    error(KIO::ERR_COULD_NOT_LOGIN, i18n("Could not initialize the SFTP session."));
-    return;
-  }
-
-  // Login succeeded!
-  infoMessage(i18n("Successfully connected to %1", mHost));
-  if (info.keepPassword) {
-    qCDebug(KIO_SFTP_LOG) << "Caching info.username = " << info.username
-                        << ", info.url = " << info.url.toDisplayString();
-    cacheAuthentication(info);
-  }
-
-  // Update the original username in case it was changed!
-  if (!mUsername.isEmpty()) {
-      mUsername = info.username;
-  }
-
-  setTimeoutSpecialCommand(KIO_SFTP_SPECIAL_TIMEOUT);
-
-  mConnected = true;
-  connected();
-
-  info.password.fill('x');
-  info.password.clear();
+    setTimeoutSpecialCommand(KIO_SFTP_SPECIAL_TIMEOUT);
+
+    mConnected = true;
+    connected();
+
+    info.password.fill('x');
+    info.password.clear();
 }
 
 void sftpProtocol::closeConnection() {
-  qCDebug(KIO_SFTP_LOG);
+    qCDebug(KIO_SFTP_LOG);
 
-  if (mSftp) {
-    sftp_free(mSftp);
-    mSftp = nullptr;
-  }
+    if (mSftp) {
+        sftp_free(mSftp);
+        mSftp = nullptr;
+    }
 
-  if (mSession) {
-    ssh_disconnect(mSession);
-    mSession = nullptr;
-  }
+    if (mSession) {
+        ssh_disconnect(mSession);
+        mSession = nullptr;
+    }
 
-  mConnected = false;
+    mConnected = false;
 }
 
 void sftpProtocol::special(const QByteArray &) {
@@ -977,1130 +977,1130 @@ void sftpProtocol::special(const QByteArray &) {
 }
 
 void sftpProtocol::open(const QUrl &url, QIODevice::OpenMode mode) {
-  qCDebug(KIO_SFTP_LOG) << "open: " << url;
+    qCDebug(KIO_SFTP_LOG) << "open: " << url;
 
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
+    if (!sftpLogin()) {
+        // sftpLogin finished()
+        return;
+    }
 
-  const QString path = url.path();
-  const QByteArray path_c = path.toUtf8();
+    const QString path = url.path();
+    const QByteArray path_c = path.toUtf8();
 
-  sftp_attributes sb = sftp_lstat(mSftp, path_c.constData());
-  if (sb == nullptr) {
-    reportError(url, sftp_get_error(mSftp));
-    return;
-  }
+    sftp_attributes sb = sftp_lstat(mSftp, path_c.constData());
+    if (sb == nullptr) {
+        reportError(url, sftp_get_error(mSftp));
+        return;
+    }
 
-  switch (sb->type) {
+    switch (sb->type) {
     case SSH_FILEXFER_TYPE_DIRECTORY:
-      error(KIO::ERR_IS_DIRECTORY, url.toDisplayString());
-      sftp_attributes_free(sb);
-      return;
+        error(KIO::ERR_IS_DIRECTORY, url.toDisplayString());
+        sftp_attributes_free(sb);
+        return;
     case SSH_FILEXFER_TYPE_SPECIAL:
     case SSH_FILEXFER_TYPE_UNKNOWN:
-      error(KIO::ERR_CANNOT_OPEN_FOR_READING, url.toDisplayString());
-      sftp_attributes_free(sb);
-      return;
+        error(KIO::ERR_CANNOT_OPEN_FOR_READING, url.toDisplayString());
+        sftp_attributes_free(sb);
+        return;
     case SSH_FILEXFER_TYPE_SYMLINK:
     case SSH_FILEXFER_TYPE_REGULAR:
-      break;
-  }
+        break;
+    }
 
-  KIO::filesize_t fileSize = sb->size;
-  sftp_attributes_free(sb);
+    KIO::filesize_t fileSize = sb->size;
+    sftp_attributes_free(sb);
 
-  int flags = 0;
+    int flags = 0;
 
-  if (mode & QIODevice::ReadOnly) {
-    if (mode & QIODevice::WriteOnly) {
-      flags = O_RDWR | O_CREAT;
-    } else {
-      flags = O_RDONLY;
-    }
-  } else if (mode & QIODevice::WriteOnly) {
-    flags = O_WRONLY | O_CREAT;
-  }
-
-  if (mode & QIODevice::Append) {
-    flags |= O_APPEND;
-  } else if (mode & QIODevice::Truncate) {
-    flags |= O_TRUNC;
-  }
-
-  if (flags & O_CREAT) {
-    mOpenFile = sftp_open(mSftp, path_c.constData(), flags, 0644);
-  } else {
-    mOpenFile = sftp_open(mSftp, path_c.constData(), flags, 0);
-  }
-
-  if (mOpenFile == nullptr) {
-    error(KIO::ERR_CANNOT_OPEN_FOR_READING, path);
-    return;
-  }
-
-  // Determine the mimetype of the file to be retrieved, and emit it.
-  // This is mandatory in all slaves (for KRun/BrowserRun to work).
-  // If we're not opening the file ReadOnly or ReadWrite, don't attempt to
-  // read the file and send the mimetype.
-  if (mode & QIODevice::ReadOnly) {
-    size_t bytesRequested = 1024;
-    ssize_t bytesRead = 0;
-    QVarLengthArray<char> buffer(bytesRequested);
-
-    bytesRead = sftp_read(mOpenFile, buffer.data(), bytesRequested);
-    if (bytesRead < 0) {
-      error(KIO::ERR_COULD_NOT_READ, mOpenUrl.toDisplayString());
-      closeWithoutFinish();
-      return;
+    if (mode & QIODevice::ReadOnly) {
+        if (mode & QIODevice::WriteOnly) {
+            flags = O_RDWR | O_CREAT;
+        } else {
+            flags = O_RDONLY;
+        }
+    } else if (mode & QIODevice::WriteOnly) {
+        flags = O_WRONLY | O_CREAT;
+    }
+
+    if (mode & QIODevice::Append) {
+        flags |= O_APPEND;
+    } else if (mode & QIODevice::Truncate) {
+        flags |= O_TRUNC;
+    }
+
+    if (flags & O_CREAT) {
+        mOpenFile = sftp_open(mSftp, path_c.constData(), flags, 0644);
     } else {
-      QByteArray fileData = QByteArray::fromRawData(buffer.data(), bytesRead);
-      QMimeDatabase db;
-      QMimeType mime = db.mimeTypeForFileNameAndData(mOpenUrl.fileName(), fileData);
-      emit mimeType(mime.name());
+        mOpenFile = sftp_open(mSftp, path_c.constData(), flags, 0);
+    }
 
-      // Go back to the beginning of the file.
-      sftp_rewind(mOpenFile);
+    if (mOpenFile == nullptr) {
+        error(KIO::ERR_CANNOT_OPEN_FOR_READING, path);
+        return;
+    }
+
+    // Determine the mimetype of the file to be retrieved, and emit it.
+    // This is mandatory in all slaves (for KRun/BrowserRun to work).
+    // If we're not opening the file ReadOnly or ReadWrite, don't attempt to
+    // read the file and send the mimetype.
+    if (mode & QIODevice::ReadOnly) {
+        size_t bytesRequested = 1024;
+        ssize_t bytesRead = 0;
+        QVarLengthArray<char> buffer(bytesRequested);
+
+        bytesRead = sftp_read(mOpenFile, buffer.data(), bytesRequested);
+        if (bytesRead < 0) {
+            error(KIO::ERR_COULD_NOT_READ, mOpenUrl.toDisplayString());
+            closeWithoutFinish();
+            return;
+        } else {
+            QByteArray fileData = QByteArray::fromRawData(buffer.data(), bytesRead);
+            QMimeDatabase db;
+            QMimeType mime = db.mimeTypeForFileNameAndData(mOpenUrl.fileName(), fileData);
+            emit mimeType(mime.name());
+
+            // Go back to the beginning of the file.
+            sftp_rewind(mOpenFile);
+        }
     }
-  }
 
-  mOpenUrl = url;
+    mOpenUrl = url;
 
-  openOffset = 0;
-  totalSize(fileSize);
-  position(0);
-  opened();
-  finished();
+    openOffset = 0;
+    totalSize(fileSize);
+    position(0);
+    opened();
+    finished();
 }
 
 void sftpProtocol::read(KIO::filesize_t bytes) {
-  qCDebug(KIO_SFTP_LOG) << "read, offset = " << openOffset << ", bytes = " << bytes;
+    qCDebug(KIO_SFTP_LOG) << "read, offset = " << openOffset << ", bytes = " << bytes;
 
-  Q_ASSERT(mOpenFile != nullptr);
+    Q_ASSERT(mOpenFile != nullptr);
 
-  QVarLengthArray<char> buffer(bytes);
+    QVarLengthArray<char> buffer(bytes);
 
-  ssize_t bytesRead = sftp_read(mOpenFile, buffer.data(), bytes);
-  Q_ASSERT(bytesRead <= static_cast<ssize_t>(bytes));
+    ssize_t bytesRead = sftp_read(mOpenFile, buffer.data(), bytes);
+    Q_ASSERT(bytesRead <= static_cast<ssize_t>(bytes));
 
-  if (bytesRead < 0) {
-    qCDebug(KIO_SFTP_LOG) << "Could not read " << mOpenUrl;
-    error(KIO::ERR_COULD_NOT_READ, mOpenUrl.toDisplayString());
-    closeWithoutFinish();
-    return;
-  }
+    if (bytesRead < 0) {
+        qCDebug(KIO_SFTP_LOG) << "Could not read " << mOpenUrl;
+        error(KIO::ERR_COULD_NOT_READ, mOpenUrl.toDisplayString());
+        closeWithoutFinish();
+        return;
+    }
 
-  const QByteArray fileData = QByteArray::fromRawData(buffer.data(), bytesRead);
-  data(fileData);
-  finished();
+    const QByteArray fileData = QByteArray::fromRawData(buffer.data(), bytesRead);
+    data(fileData);
+    finished();
 }
 
 void sftpProtocol::write(const QByteArray &data) {
-  qCDebug(KIO_SFTP_LOG) << "write, offset = " << openOffset << ", bytes = " << data.size();
+    qCDebug(KIO_SFTP_LOG) << "write, offset = " << openOffset << ", bytes = " << data.size();
 
-  Q_ASSERT(mOpenFile != nullptr);
+    Q_ASSERT(mOpenFile != nullptr);
 
-  ssize_t bytesWritten = sftp_write(mOpenFile, data.data(), data.size());
-  if (bytesWritten < 0) {
-    qCDebug(KIO_SFTP_LOG) << "Could not write to " << mOpenUrl;
-    error(KIO::ERR_COULD_NOT_WRITE, mOpenUrl.toDisplayString());
-    closeWithoutFinish();
-    return;
-  }
+    ssize_t bytesWritten = sftp_write(mOpenFile, data.data(), data.size());
+    if (bytesWritten < 0) {
+        qCDebug(KIO_SFTP_LOG) << "Could not write to " << mOpenUrl;
+        error(KIO::ERR_COULD_NOT_WRITE, mOpenUrl.toDisplayString());
+        closeWithoutFinish();
+        return;
+    }
 
-  written(bytesWritten);
-  finished();
+    written(bytesWritten);
+    finished();
 }
 
 void sftpProtocol::seek(KIO::filesize_t offset) {
-  qCDebug(KIO_SFTP_LOG) << "seek, offset = " << offset;
+    qCDebug(KIO_SFTP_LOG) << "seek, offset = " << offset;
 
-  Q_ASSERT(mOpenFile != nullptr);
+    Q_ASSERT(mOpenFile != nullptr);
 
-  if (sftp_seek64(mOpenFile, static_cast<uint64_t>(offset)) < 0) {
-    error(KIO::ERR_COULD_NOT_SEEK, mOpenUrl.path());
-    closeWithoutFinish();
-    return;
-  }
+    if (sftp_seek64(mOpenFile, static_cast<uint64_t>(offset)) < 0) {
+        error(KIO::ERR_COULD_NOT_SEEK, mOpenUrl.path());
+        closeWithoutFinish();
+        return;
+    }
 
-  position(sftp_tell64(mOpenFile));
-  finished();
+    position(sftp_tell64(mOpenFile));
+    finished();
 }
 
 void sftpProtocol::close() {
-  closeWithoutFinish();
-  finished();
+    closeWithoutFinish();
+    finished();
 }
 
 void sftpProtocol::get(const QUrl& url) {
-  qCDebug(KIO_SFTP_LOG) << url;
+    qCDebug(KIO_SFTP_LOG) << url;
 
-  int errorCode = 0;
-  const sftpProtocol::StatusCode cs = sftpGet(url, errorCode);
+    int errorCode = 0;
+    const sftpProtocol::StatusCode cs = sftpGet(url, errorCode);
 
-  // The call to sftpGet should only return server side errors since the file
-  // descriptor parameter is set to -1.
-  if (cs == sftpProtocol::ServerError && errorCode) {
-     error(errorCode, url.toDisplayString());
-     return;
-  }
+    // The call to sftpGet should only return server side errors since the file
+    // descriptor parameter is set to -1.
+    if (cs == sftpProtocol::ServerError && errorCode) {
+        error(errorCode, url.toDisplayString());
+        return;
+    }
 
-  finished();
+    finished();
 }
 
 sftpProtocol::StatusCode sftpProtocol::sftpGet(const QUrl& url, int& errorCode, KIO::fileoffset_t offset, int fd) {
 
-  qCDebug(KIO_SFTP_LOG) << url;
+    qCDebug(KIO_SFTP_LOG) << url;
 
-  if (!sftpLogin()) {
-    return sftpProtocol::ServerError;
-  }
+    if (!sftpLogin()) {
+        return sftpProtocol::ServerError;
+    }
 
-  QByteArray path = url.path().toUtf8();
+    QByteArray path = url.path().toUtf8();
 
-  sftp_file file = nullptr;
-  KIO::filesize_t totalbytesread  = 0;
-  QByteArray filedata;
+    sftp_file file = nullptr;
+    KIO::filesize_t totalbytesread  = 0;
+    QByteArray filedata;
 
-  sftp_attributes sb = sftp_lstat(mSftp, path.constData());
-  if (sb == nullptr) {
-    errorCode = toKIOError(sftp_get_error(mSftp));
-    return sftpProtocol::ServerError;
-  }
+    sftp_attributes sb = sftp_lstat(mSftp, path.constData());
+    if (sb == nullptr) {
+        errorCode = toKIOError(sftp_get_error(mSftp));
+        return sftpProtocol::ServerError;
+    }
 
-  switch (sb->type) {
+    switch (sb->type) {
     case SSH_FILEXFER_TYPE_DIRECTORY:
-      errorCode = KIO::ERR_IS_DIRECTORY;
-      sftp_attributes_free(sb);
-      return sftpProtocol::ServerError;
+        errorCode = KIO::ERR_IS_DIRECTORY;
+        sftp_attributes_free(sb);
+        return sftpProtocol::ServerError;
     case SSH_FILEXFER_TYPE_SPECIAL:
     case SSH_FILEXFER_TYPE_UNKNOWN:
-      errorCode = KIO::ERR_CANNOT_OPEN_FOR_READING;
-      sftp_attributes_free(sb);
-      return sftpProtocol::ServerError;
+        errorCode = KIO::ERR_CANNOT_OPEN_FOR_READING;
+        sftp_attributes_free(sb);
+        return sftpProtocol::ServerError;
     case SSH_FILEXFER_TYPE_SYMLINK:
     case SSH_FILEXFER_TYPE_REGULAR:
-      break;
-  }
-
-  // Open file
-  file = sftp_open(mSftp, path.constData(), O_RDONLY, 0);
-  if (file == nullptr) {
-    errorCode = KIO::ERR_CANNOT_OPEN_FOR_READING;
-    sftp_attributes_free(sb);
-    return sftpProtocol::ServerError;
-  }
-
-  char mimeTypeBuf[1024];
-  ssize_t bytesread = sftp_read(file, mimeTypeBuf, sizeof(mimeTypeBuf));
-
-  if (bytesread < 0) {
-    errorCode = KIO::ERR_COULD_NOT_READ;
-    return sftpProtocol::ServerError;
-  } else  {
-    QMimeDatabase db;
-    QMimeType mime = db.mimeTypeForFileNameAndData(url.fileName(), QByteArray(mimeTypeBuf, bytesread));
-    if (!mime.isDefault()) {
-      emit mimeType(mime.name());
-    } else {
-      mime = db.mimeTypeForUrl(url);
-      emit mimeType(mime.name());
-    }
-    sftp_rewind(file);
-  }
-
-  // Set the total size
-  totalSize(sb->size);
-
-  // If offset is not specified, check the "resume" meta-data.
-  if (offset < 0) {
-    const QString resumeOffsetStr = metaData(QLatin1String("resume"));
-    if (!resumeOffsetStr.isEmpty()) {
-      bool ok;
-      qlonglong resumeOffset = resumeOffsetStr.toLongLong(&ok);
-      if (ok) {
-        offset = resumeOffset;
-      }
-    }
-  }
-
-  // If we can resume, offset the buffer properly.
-  if (offset > 0 && ((unsigned long long) offset < sb->size))
-  {
-    if (sftp_seek64(file, offset) == 0) {
-      canResume();
-      totalbytesread = offset;
-      qCDebug(KIO_SFTP_LOG) << "Resume offset: " << QString::number(offset);
-    }
-  }
-
-  bytesread = 0;
-  sftpProtocol::GetRequest request(file, sb);
-
-  for (;;) {
-    // Enqueue get requests
-    if (!request.enqueueChunks()) {
-      errorCode = KIO::ERR_COULD_NOT_READ;
-      return sftpProtocol::ServerError;
-    }
-
-    filedata.clear();
-    bytesread = request.readChunks(filedata);
-    // Read pending get requests
-    if (bytesread == -1) {
-      errorCode = KIO::ERR_COULD_NOT_READ;
-      return sftpProtocol::ServerError;
-    } else if (bytesread == 0) {
-      if (file->eof)
         break;
-      else
-        continue;
     }
 
-    if (fd == -1) {
-        data(filedata);
-    } else if ((errorCode = writeToFile(fd, filedata.constData(), filedata.size())) != 0) {
-        return sftpProtocol::ClientError;
+    // Open file
+    file = sftp_open(mSftp, path.constData(), O_RDONLY, 0);
+    if (file == nullptr) {
+        errorCode = KIO::ERR_CANNOT_OPEN_FOR_READING;
+        sftp_attributes_free(sb);
+        return sftpProtocol::ServerError;
+    }
+
+    char mimeTypeBuf[1024];
+    ssize_t bytesread = sftp_read(file, mimeTypeBuf, sizeof(mimeTypeBuf));
+
+    if (bytesread < 0) {
+        errorCode = KIO::ERR_COULD_NOT_READ;
+        return sftpProtocol::ServerError;
+    } else  {
+        QMimeDatabase db;
+        QMimeType mime = db.mimeTypeForFileNameAndData(url.fileName(), QByteArray(mimeTypeBuf, bytesread));
+        if (!mime.isDefault()) {
+            emit mimeType(mime.name());
+        } else {
+            mime = db.mimeTypeForUrl(url);
+            emit mimeType(mime.name());
+        }
+        sftp_rewind(file);
+    }
+
+    // Set the total size
+    totalSize(sb->size);
+
+    // If offset is not specified, check the "resume" meta-data.
+    if (offset < 0) {
+        const QString resumeOffsetStr = metaData(QLatin1String("resume"));
+        if (!resumeOffsetStr.isEmpty()) {
+            bool ok;
+            qlonglong resumeOffset = resumeOffsetStr.toLongLong(&ok);
+            if (ok) {
+                offset = resumeOffset;
+            }
+        }
     }
-    // increment total bytes read
-    totalbytesread += filedata.length();
 
-    processedSize(totalbytesread);
-  }
+    // If we can resume, offset the buffer properly.
+    if (offset > 0 && ((unsigned long long) offset < sb->size))
+    {
+        if (sftp_seek64(file, offset) == 0) {
+            canResume();
+            totalbytesread = offset;
+            qCDebug(KIO_SFTP_LOG) << "Resume offset: " << QString::number(offset);
+        }
+    }
+
+    bytesread = 0;
+    sftpProtocol::GetRequest request(file, sb);
+
+    for (;;) {
+        // Enqueue get requests
+        if (!request.enqueueChunks()) {
+            errorCode = KIO::ERR_COULD_NOT_READ;
+            return sftpProtocol::ServerError;
+        }
+
+        filedata.clear();
+        bytesread = request.readChunks(filedata);
+        // Read pending get requests
+        if (bytesread == -1) {
+            errorCode = KIO::ERR_COULD_NOT_READ;
+            return sftpProtocol::ServerError;
+        } else if (bytesread == 0) {
+            if (file->eof)
+                break;
+            else
+                continue;
+        }
+
+        if (fd == -1) {
+            data(filedata);
+        } else if ((errorCode = writeToFile(fd, filedata.constData(), filedata.size())) != 0) {
+            return sftpProtocol::ClientError;
+        }
+        // increment total bytes read
+        totalbytesread += filedata.length();
 
-  if (fd == -1)
-      data(QByteArray());
+        processedSize(totalbytesread);
+    }
+
+    if (fd == -1)
+        data(QByteArray());
 
-  processedSize(static_cast<KIO::filesize_t>(sb->size));
-  return sftpProtocol::Success;
+    processedSize(static_cast<KIO::filesize_t>(sb->size));
+    return sftpProtocol::Success;
 }
 
 void sftpProtocol::put(const QUrl& url, int permissions, KIO::JobFlags flags) {
-  qCDebug(KIO_SFTP_LOG) << url << ", permissions =" << permissions
-                      << ", overwrite =" << (flags & KIO::Overwrite)
-                      << ", resume =" << (flags & KIO::Resume);
+    qCDebug(KIO_SFTP_LOG) << url << ", permissions =" << permissions
+                          << ", overwrite =" << (flags & KIO::Overwrite)
+                          << ", resume =" << (flags & KIO::Resume);
 
-  qCDebug(KIO_SFTP_LOG) << url;
+    qCDebug(KIO_SFTP_LOG) << url;
 
-  int errorCode = 0;
-  const sftpProtocol::StatusCode cs = sftpPut(url, permissions, flags, errorCode);
+    int errorCode = 0;
+    const sftpProtocol::StatusCode cs = sftpPut(url, permissions, flags, errorCode);
 
-  // The call to sftpPut should only return server side errors since the file
-  // descriptor parameter is set to -1.
-  if (cs == sftpProtocol::ServerError && errorCode) {
-     error(errorCode, url.toDisplayString());
-     return;
-  }
+    // The call to sftpPut should only return server side errors since the file
+    // descriptor parameter is set to -1.
+    if (cs == sftpProtocol::ServerError && errorCode) {
+        error(errorCode, url.toDisplayString());
+        return;
+    }
 
-  finished();
+    finished();
 }
 
 sftpProtocol::StatusCode sftpProtocol::sftpPut(const QUrl& url, int permissions, JobFlags flags, int& errorCode, int fd) {
-  qCDebug(KIO_SFTP_LOG) << url << ", permissions =" << permissions
-                      << ", overwrite =" << (flags & KIO::Overwrite)
-                      << ", resume =" << (flags & KIO::Resume);
-
-  if (!sftpLogin()) {
-    return sftpProtocol::ServerError;
-  }
-
-  const QString dest_orig = url.path();
-  const QByteArray dest_orig_c = dest_orig.toUtf8();
-  const QString dest_part = dest_orig + ".part";
-  const QByteArray dest_part_c = dest_part.toUtf8();
-  uid_t owner = 0;
-  gid_t group = 0;
-
-  sftp_attributes sb = sftp_lstat(mSftp, dest_orig_c.constData());
-  const bool bOrigExists = (sb != nullptr);
-  bool bPartExists = false;
-  const bool bMarkPartial = config()->readEntry("MarkPartial", true);
-
-  // Don't change permissions of the original file
-  if (bOrigExists) {
-      permissions = sb->permissions;
-      owner = sb->uid;
-      group = sb->gid;
-  }
-
-  if (bMarkPartial) {
-    sftp_attributes sbPart = sftp_lstat(mSftp, dest_part_c.constData());
-    bPartExists = (sbPart != nullptr);
-
-    if (bPartExists && !(flags & KIO::Resume) && !(flags & KIO::Overwrite) &&
-        sbPart->size > 0 && sbPart->type == SSH_FILEXFER_TYPE_REGULAR) {
-
-      if (fd == -1) {
-        // Maybe we can use this partial file for resuming
-        // Tell about the size we have, and the app will tell us
-        // if it's ok to resume or not.
-        qCDebug(KIO_SFTP_LOG) << "calling canResume with " << sbPart->size;
-        flags |= canResume(sbPart->size) ? KIO::Resume : KIO::DefaultFlags;
-        qCDebug(KIO_SFTP_LOG) << "put got answer " << (flags & KIO::Resume);
-
-      } else {
-        KIO::filesize_t pos = seekPos(fd, sbPart->size, SEEK_SET);
-        if (pos != sbPart->size) {
-          qCDebug(KIO_SFTP_LOG) << "Failed to seek to" << sbPart->size << "bytes in source file. Reason given" << strerror(errno);
-          sftp_attributes_free(sb);
-          sftp_attributes_free(sbPart);
-          errorCode = ERR_COULD_NOT_SEEK;
-          return sftpProtocol::ClientError;
+    qCDebug(KIO_SFTP_LOG) << url << ", permissions =" << permissions
+                          << ", overwrite =" << (flags & KIO::Overwrite)
+                          << ", resume =" << (flags & KIO::Resume);
+
+    if (!sftpLogin()) {
+        return sftpProtocol::ServerError;
+    }
+
+    const QString dest_orig = url.path();
+    const QByteArray dest_orig_c = dest_orig.toUtf8();
+    const QString dest_part = dest_orig + ".part";
+    const QByteArray dest_part_c = dest_part.toUtf8();
+    uid_t owner = 0;
+    gid_t group = 0;
+
+    sftp_attributes sb = sftp_lstat(mSftp, dest_orig_c.constData());
+    const bool bOrigExists = (sb != nullptr);
+    bool bPartExists = false;
+    const bool bMarkPartial = config()->readEntry("MarkPartial", true);
+
+    // Don't change permissions of the original file
+    if (bOrigExists) {
+        permissions = sb->permissions;
+        owner = sb->uid;
+        group = sb->gid;
+    }
+
+    if (bMarkPartial) {
+        sftp_attributes sbPart = sftp_lstat(mSftp, dest_part_c.constData());
+        bPartExists = (sbPart != nullptr);
+
+        if (bPartExists && !(flags & KIO::Resume) && !(flags & KIO::Overwrite) &&
+                sbPart->size > 0 && sbPart->type == SSH_FILEXFER_TYPE_REGULAR) {
+
+            if (fd == -1) {
+                // Maybe we can use this partial file for resuming
+                // Tell about the size we have, and the app will tell us
+                // if it's ok to resume or not.
+                qCDebug(KIO_SFTP_LOG) << "calling canResume with " << sbPart->size;
+                flags |= canResume(sbPart->size) ? KIO::Resume : KIO::DefaultFlags;
+                qCDebug(KIO_SFTP_LOG) << "put got answer " << (flags & KIO::Resume);
+
+            } else {
+                KIO::filesize_t pos = seekPos(fd, sbPart->size, SEEK_SET);
+                if (pos != sbPart->size) {
+                    qCDebug(KIO_SFTP_LOG) << "Failed to seek to" << sbPart->size << "bytes in source file. Reason given" << strerror(errno);
+                    sftp_attributes_free(sb);
+                    sftp_attributes_free(sbPart);
+                    errorCode = ERR_COULD_NOT_SEEK;
+                    return sftpProtocol::ClientError;
+                }
+                flags |= KIO::Resume;
+            }
+            qCDebug(KIO_SFTP_LOG) << "Resuming at" << sbPart->size;
+            sftp_attributes_free(sbPart);
         }
-        flags |= KIO::Resume;
-      }
-      qCDebug(KIO_SFTP_LOG) << "Resuming at" << sbPart->size;
-      sftp_attributes_free(sbPart);
     }
-  }
 
-  if (bOrigExists && !(flags & KIO::Overwrite) && !(flags & KIO::Resume)) {
-    errorCode = KSFTP_ISDIR(sb) ? KIO::ERR_DIR_ALREADY_EXIST : KIO::ERR_FILE_ALREADY_EXIST;
-    sftp_attributes_free(sb);
-    return sftpProtocol::ServerError;
-  }
+    if (bOrigExists && !(flags & KIO::Overwrite) && !(flags & KIO::Resume)) {
+        errorCode = KSFTP_ISDIR(sb) ? KIO::ERR_DIR_ALREADY_EXIST : KIO::ERR_FILE_ALREADY_EXIST;
+        sftp_attributes_free(sb);
+        return sftpProtocol::ServerError;
+    }
 
-  QByteArray dest;
-  int result = -1;
-  sftp_file file = nullptr;
-  StatusCode cs = sftpProtocol::Success;
-  KIO::fileoffset_t totalBytesSent = 0;
+    QByteArray dest;
+    int result = -1;
+    sftp_file file = nullptr;
+    StatusCode cs = sftpProtocol::Success;
+    KIO::fileoffset_t totalBytesSent = 0;
 
-  // Loop until we got 0 (end of data)
-  do {
-    QByteArray buffer;
+    // Loop until we got 0 (end of data)
+    do {
+        QByteArray buffer;
 
-    if (fd == -1) {
-      dataReq(); // Request for data
-      result = readData(buffer);
-    } else {
-      char buf[MAX_XFER_BUF_SIZE]; //
-      result = ::read(fd, buf, sizeof(buf));
-      if(result < 0) {
-        errorCode = ERR_COULD_NOT_READ;
-        cs = sftpProtocol::ClientError;
-        break;
-      }
-      buffer = QByteArray(buf, result);
-    }
-
-    if (result >= 0) {
-      if (dest.isEmpty()) {
-        if (bMarkPartial) {
-          qCDebug(KIO_SFTP_LOG) << "Appending .part extension to" << dest_orig;
-          dest = dest_part_c;
-          if (bPartExists && !(flags & KIO::Resume)) {
-            qCDebug(KIO_SFTP_LOG) << "Deleting partial file" << dest_part;
-            sftp_unlink(mSftp, dest_part_c.constData());
-            // Catch errors when we try to open the file.
-          }
+        if (fd == -1) {
+            dataReq(); // Request for data
+            result = readData(buffer);
         } else {
-          dest = dest_orig_c; // Will be automatically truncated below...
-        } // bMarkPartial
-
-        if ((flags & KIO::Resume)) {
-          sftp_attributes fstat;
-
-          qCDebug(KIO_SFTP_LOG) << "Trying to append: " << dest;
-          file = sftp_open(mSftp, dest.constData(), O_RDWR, 0);  // append if resuming
-          if (file) {
-            fstat = sftp_fstat(file);
-            if (fstat) {
-              sftp_seek64(file, fstat->size); // Seek to end TODO
-              totalBytesSent += fstat->size;
-              sftp_attributes_free(fstat);
+            char buf[MAX_XFER_BUF_SIZE]; //
+            result = ::read(fd, buf, sizeof(buf));
+            if(result < 0) {
+                errorCode = ERR_COULD_NOT_READ;
+                cs = sftpProtocol::ClientError;
+                break;
             }
-          }
-        } else {
-          mode_t initialMode;
-
-          if (permissions != -1) {
-            initialMode = permissions | S_IWUSR | S_IRUSR;
-          } else {
-            initialMode = 0644;
-          }
-
-          qCDebug(KIO_SFTP_LOG) << "Trying to open:" << QString(dest) << ", mode=" << QString::number(initialMode);
-          file = sftp_open(mSftp, dest.constData(), O_CREAT | O_TRUNC | O_WRONLY, initialMode);
-        } // flags & KIO::Resume
-
-        if (file == nullptr) {
-          qCDebug(KIO_SFTP_LOG) << "COULD NOT WRITE " << QString(dest)
-                              << ", permissions=" << permissions
-                              << ", error=" << ssh_get_error(mSession);
-          if (sftp_get_error(mSftp) == SSH_FX_PERMISSION_DENIED) {
-            errorCode = KIO::ERR_WRITE_ACCESS_DENIED;
-          } else {
-            errorCode = KIO::ERR_CANNOT_OPEN_FOR_WRITING;
-          }
-          cs = sftpProtocol::ServerError;
-          result = -1;
-          continue;
-        } // file
-      } // dest.isEmpty
-
-      ssize_t bytesWritten = sftp_write(file, buffer.data(), buffer.size());
-      if (bytesWritten < 0) {
-        errorCode = KIO::ERR_COULD_NOT_WRITE;
-        result = -1;
-      } else {
-        totalBytesSent += bytesWritten;
-        emit processedSize(totalBytesSent);
-      }
-    } // result
-  } while (result > 0);
-  sftp_attributes_free(sb);
-
-  // An error occurred deal with it.
-  if (result < 0) {
-    qCDebug(KIO_SFTP_LOG) << "Error during 'put'. Aborting.";
-
-    if (file != nullptr) {
-      sftp_close(file);
-
-      sftp_attributes attr = sftp_stat(mSftp, dest.constData());
-      if (bMarkPartial && attr != nullptr) {
-        size_t size = config()->readEntry("MinimumKeepSize", DEFAULT_MINIMUM_KEEP_SIZE);
-        if (attr->size < size) {
-          sftp_unlink(mSftp, dest.constData());
+            buffer = QByteArray(buf, result);
         }
-      }
-      sftp_attributes_free(attr);
+
+        if (result >= 0) {
+            if (dest.isEmpty()) {
+                if (bMarkPartial) {
+                    qCDebug(KIO_SFTP_LOG) << "Appending .part extension to" << dest_orig;
+                    dest = dest_part_c;
+                    if (bPartExists && !(flags & KIO::Resume)) {
+                        qCDebug(KIO_SFTP_LOG) << "Deleting partial file" << dest_part;
+                        sftp_unlink(mSftp, dest_part_c.constData());
+                        // Catch errors when we try to open the file.
+                    }
+                } else {
+                    dest = dest_orig_c; // Will be automatically truncated below...
+                } // bMarkPartial
+
+                if ((flags & KIO::Resume)) {
+                    sftp_attributes fstat;
+
+                    qCDebug(KIO_SFTP_LOG) << "Trying to append: " << dest;
+                    file = sftp_open(mSftp, dest.constData(), O_RDWR, 0);  // append if resuming
+                    if (file) {
+                        fstat = sftp_fstat(file);
+                        if (fstat) {
+                            sftp_seek64(file, fstat->size); // Seek to end TODO
+                            totalBytesSent += fstat->size;
+                            sftp_attributes_free(fstat);
+                        }
+                    }
+                } else {
+                    mode_t initialMode;
+
+                    if (permissions != -1) {
+                        initialMode = permissions | S_IWUSR | S_IRUSR;
+                    } else {
+                        initialMode = 0644;
+                    }
+
+                    qCDebug(KIO_SFTP_LOG) << "Trying to open:" << QString(dest) << ", mode=" << QString::number(initialMode);
+                    file = sftp_open(mSftp, dest.constData(), O_CREAT | O_TRUNC | O_WRONLY, initialMode);
+                } // flags & KIO::Resume
+
+                if (file == nullptr) {
+                    qCDebug(KIO_SFTP_LOG) << "COULD NOT WRITE " << QString(dest)
+                                          << ", permissions=" << permissions
+                                          << ", error=" << ssh_get_error(mSession);
+                    if (sftp_get_error(mSftp) == SSH_FX_PERMISSION_DENIED) {
+                        errorCode = KIO::ERR_WRITE_ACCESS_DENIED;
+                    } else {
+                        errorCode = KIO::ERR_CANNOT_OPEN_FOR_WRITING;
+                    }
+                    cs = sftpProtocol::ServerError;
+                    result = -1;
+                    continue;
+                } // file
+            } // dest.isEmpty
+
+            ssize_t bytesWritten = sftp_write(file, buffer.data(), buffer.size());
+            if (bytesWritten < 0) {
+                errorCode = KIO::ERR_COULD_NOT_WRITE;
+                result = -1;
+            } else {
+                totalBytesSent += bytesWritten;
+                emit processedSize(totalBytesSent);
+            }
+        } // result
+    } while (result > 0);
+    sftp_attributes_free(sb);
+
+    // An error occurred deal with it.
+    if (result < 0) {
+        qCDebug(KIO_SFTP_LOG) << "Error during 'put'. Aborting.";
+
+        if (file != nullptr) {
+            sftp_close(file);
+
+            sftp_attributes attr = sftp_stat(mSftp, dest.constData());
+            if (bMarkPartial && attr != nullptr) {
+                size_t size = config()->readEntry("MinimumKeepSize", DEFAULT_MINIMUM_KEEP_SIZE);
+                if (attr->size < size) {
+                    sftp_unlink(mSftp, dest.constData());
+                }
+            }
+            sftp_attributes_free(attr);
+        }
+
+        //::exit(255);
+        return cs;
     }
 
-    //::exit(255);
-    return cs;
-  }
+    if (file == nullptr) { // we got nothing to write out, so we never opened the file
+        return sftpProtocol::Success;
+    }
 
-  if (file == nullptr) { // we got nothing to write out, so we never opened the file
-    return sftpProtocol::Success;
-  }
-
-  if (sftp_close(file) < 0) {
-    qCWarning(KIO_SFTP_LOG) << "Error when closing file descriptor";
-    error(KIO::ERR_COULD_NOT_WRITE, dest_orig);
-    return sftpProtocol::ServerError;
-  }
-
-  // after full download rename the file back to original name
-  if (bMarkPartial) {
-    // If the original URL is a symlink and we were asked to overwrite it,
-    // remove the symlink first. This ensures that we do not overwrite the
-    // current source if the symlink points to it.
-    if ((flags & KIO::Overwrite)) {
-      sftp_unlink(mSftp, dest_orig_c.constData());
-    }
-
-    if (sftp_rename(mSftp, dest.constData(), dest_orig_c.constData()) < 0) {
-      qCWarning(KIO_SFTP_LOG) << " Couldn't rename " << dest << " to " << dest_orig;
-      errorCode = KIO::ERR_CANNOT_RENAME_PARTIAL;
-      return sftpProtocol::ServerError;
-    }
-  }
-
-  // set final permissions
-  if (permissions != -1 && !(flags & KIO::Resume)) {
-    qCDebug(KIO_SFTP_LOG) << "Trying to set final permissions of " << dest_orig << " to " << QString::number(permissions);
-    if (sftp_chmod(mSftp, dest_orig_c.constData(), permissions) < 0) {
-      errorCode = -1;  // force copy to call sftpSendWarning...
-      return sftpProtocol::ServerError;
-    }
-  }
-
-  // set original owner and group
-  if (bOrigExists) {
-    qCDebug(KIO_SFTP_LOG) << "Trying to restore original owner and group of " << dest_orig;
-    if (sftp_chown(mSftp, dest_orig_c.constData(), owner, group) < 0) {
-      qCWarning(KIO_SFTP_LOG) << "Could not change owner and group for" << dest_orig;
-      // warning(i18n( "Could not change owner and group for\n%1", dest_orig));
-    }
-  }
-
-  // set modification time
-  const QString mtimeStr = metaData("modified");
-  if (!mtimeStr.isEmpty()) {
-    QDateTime dt = QDateTime::fromString(mtimeStr, Qt::ISODate);
-    if (dt.isValid()) {
-      struct timeval times[2];
-
-      sftp_attributes attr = sftp_lstat(mSftp, dest_orig_c.constData());
-      if (attr != nullptr) {
-        times[0].tv_sec = attr->atime; //// access time, unchanged
-        times[1].tv_sec =  dt.toTime_t(); // modification time
-        times[0].tv_usec = times[1].tv_usec = 0;
-
-        qCDebug(KIO_SFTP_LOG) << "Trying to restore mtime for " << dest_orig << " to: " << mtimeStr;
-        result = sftp_utimes(mSftp, dest_orig_c.constData(), times);
-        if (result < 0) {
-            qCWarning(KIO_SFTP_LOG) << "Failed to set mtime for" << dest_orig;
+    if (sftp_close(file) < 0) {
+        qCWarning(KIO_SFTP_LOG) << "Error when closing file descriptor";
+        error(KIO::ERR_COULD_NOT_WRITE, dest_orig);
+        return sftpProtocol::ServerError;
+    }
+
+    // after full download rename the file back to original name
+    if (bMarkPartial) {
+        // If the original URL is a symlink and we were asked to overwrite it,
+        // remove the symlink first. This ensures that we do not overwrite the
+        // current source if the symlink points to it.
+        if ((flags & KIO::Overwrite)) {
+            sftp_unlink(mSftp, dest_orig_c.constData());
+        }
+
+        if (sftp_rename(mSftp, dest.constData(), dest_orig_c.constData()) < 0) {
+            qCWarning(KIO_SFTP_LOG) << " Couldn't rename " << dest << " to " << dest_orig;
+            errorCode = KIO::ERR_CANNOT_RENAME_PARTIAL;
+            return sftpProtocol::ServerError;
+        }
+    }
+
+    // set final permissions
+    if (permissions != -1 && !(flags & KIO::Resume)) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to set final permissions of " << dest_orig << " to " << QString::number(permissions);
+        if (sftp_chmod(mSftp, dest_orig_c.constData(), permissions) < 0) {
+            errorCode = -1;  // force copy to call sftpSendWarning...
+            return sftpProtocol::ServerError;
+        }
+    }
+
+    // set original owner and group
+    if (bOrigExists) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to restore original owner and group of " << dest_orig;
+        if (sftp_chown(mSftp, dest_orig_c.constData(), owner, group) < 0) {
+            qCWarning(KIO_SFTP_LOG) << "Could not change owner and group for" << dest_orig;
+            // warning(i18n( "Could not change owner and group for\n%1", dest_orig));
+        }
+    }
+
+    // set modification time
+    const QString mtimeStr = metaData("modified");
+    if (!mtimeStr.isEmpty()) {
+        QDateTime dt = QDateTime::fromString(mtimeStr, Qt::ISODate);
+        if (dt.isValid()) {
+            struct timeval times[2];
+
+            sftp_attributes attr = sftp_lstat(mSftp, dest_orig_c.constData());
+            if (attr != nullptr) {
+                times[0].tv_sec = attr->atime; //// access time, unchanged
+                times[1].tv_sec =  dt.toTime_t(); // modification time
+                times[0].tv_usec = times[1].tv_usec = 0;
+
+                qCDebug(KIO_SFTP_LOG) << "Trying to restore mtime for " << dest_orig << " to: " << mtimeStr;
+                result = sftp_utimes(mSftp, dest_orig_c.constData(), times);
+                if (result < 0) {
+                    qCWarning(KIO_SFTP_LOG) << "Failed to set mtime for" << dest_orig;
+                }
+                sftp_attributes_free(attr);
+            }
         }
-        sftp_attributes_free(attr);
-      }
     }
-  }
 
-  return sftpProtocol::Success;
+    return sftpProtocol::Success;
 }
 
 void sftpProtocol::copy(const QUrl &src, const QUrl &dest, int permissions, KIO::JobFlags flags)
 {
-  qCDebug(KIO_SFTP_LOG) << src << " -> " << dest << " , permissions = " << QString::number(permissions)
-                                      << ", overwrite = " << (flags & KIO::Overwrite)
-                                      << ", resume = " << (flags & KIO::Resume);
-
-  QString sCopyFile;
-  int errorCode = 0;
-  StatusCode cs = sftpProtocol::ClientError;
-  const bool isSourceLocal = src.isLocalFile();
-  const bool isDestinationLocal = dest.isLocalFile();
-
-  if (!isSourceLocal && isDestinationLocal) {                   // sftp -> file
-    sCopyFile = dest.toLocalFile();
-    cs = sftpCopyGet(src, sCopyFile, permissions, flags, errorCode);
-    if (cs == sftpProtocol::ServerError)
-      sCopyFile = src.url();
-  } else if (isSourceLocal && !isDestinationLocal) {            // file -> sftp
-    sCopyFile = src.toLocalFile();
-    cs = sftpCopyPut(dest, sCopyFile, permissions, flags, errorCode);
-    if (cs == sftpProtocol::ServerError)
-        sCopyFile = dest.url();
-  } else {
-    errorCode = KIO::ERR_UNSUPPORTED_ACTION;
-    sCopyFile.clear();
-  }
-
-  if (cs != sftpProtocol::Success && errorCode > 0) {
-    error(errorCode, sCopyFile);
-    return;
-  }
-
-  if (errorCode < 0) {
-    sftpSendWarning(errorCode, sCopyFile);
-  }
-
-  finished();
+    qCDebug(KIO_SFTP_LOG) << src << " -> " << dest << " , permissions = " << QString::number(permissions)
+                          << ", overwrite = " << (flags & KIO::Overwrite)
+                          << ", resume = " << (flags & KIO::Resume);
+
+    QString sCopyFile;
+    int errorCode = 0;
+    StatusCode cs = sftpProtocol::ClientError;
+    const bool isSourceLocal = src.isLocalFile();
+    const bool isDestinationLocal = dest.isLocalFile();
+
+    if (!isSourceLocal && isDestinationLocal) {                   // sftp -> file
+        sCopyFile = dest.toLocalFile();
+        cs = sftpCopyGet(src, sCopyFile, permissions, flags, errorCode);
+        if (cs == sftpProtocol::ServerError)
+            sCopyFile = src.url();
+    } else if (isSourceLocal && !isDestinationLocal) {            // file -> sftp
+        sCopyFile = src.toLocalFile();
+        cs = sftpCopyPut(dest, sCopyFile, permissions, flags, errorCode);
+        if (cs == sftpProtocol::ServerError)
+            sCopyFile = dest.url();
+    } else {
+        errorCode = KIO::ERR_UNSUPPORTED_ACTION;
+        sCopyFile.clear();
+    }
+
+    if (cs != sftpProtocol::Success && errorCode > 0) {
+        error(errorCode, sCopyFile);
+        return;
+    }
+
+    if (errorCode < 0) {
+        sftpSendWarning(errorCode, sCopyFile);
+    }
+
+    finished();
 }
 
 sftpProtocol::StatusCode sftpProtocol::sftpCopyGet(const QUrl& url, const QString& sCopyFile, int permissions, KIO::JobFlags flags, int& errorCode)
 {
-  qCDebug(KIO_SFTP_LOG) << url << "->" << sCopyFile << ", permissions=" << permissions;
-
-  // check if destination is ok ...
-  QT_STATBUF buff;
-  const bool bDestExists = (QT_STAT(QFile::encodeName(sCopyFile), &buff) != -1);
-
-  if(bDestExists)  {
-    if(S_ISDIR(buff.st_mode)) {
-      errorCode = ERR_IS_DIRECTORY;
-      return sftpProtocol::ClientError;
-    }
-
-    if(!(flags & KIO::Overwrite)) {
-      errorCode = ERR_FILE_ALREADY_EXIST;
-      return sftpProtocol::ClientError;
-    }
-  }
-
-  bool bResume = false;
-  const QString sPart = sCopyFile + QLatin1String(".part"); // do we have a ".part" file?
-  const bool bPartExists = (QT_STAT(QFile::encodeName(sPart), &buff) != -1);
-  const bool bMarkPartial = config()->readEntry("MarkPartial", true);
-  const QString dest = (bMarkPartial ? sPart : sCopyFile);
-
-  if (bMarkPartial && bPartExists && buff.st_size > 0) {
-    if (S_ISDIR(buff.st_mode)) {
-      errorCode = ERR_DIR_ALREADY_EXIST;
-      return sftpProtocol::ClientError;                            // client side error
-    }
-    bResume = canResume( buff.st_size );
-  }
-
-  if (bPartExists && !bResume)                  // get rid of an unwanted ".part" file
-    QFile::remove(sPart);
-
-  // WABA: Make sure that we keep writing permissions ourselves,
-  // otherwise we can be in for a surprise on NFS.
-  mode_t initialMode;
-  if (permissions != -1)
-    initialMode = permissions | S_IWUSR;
-  else
-    initialMode = 0666;
-
-  // open the output file ...
-  int fd = -1;
-  KIO::fileoffset_t offset = 0;
-  if (bResume) {
-    fd = QT_OPEN( QFile::encodeName(sPart), O_RDWR );  // append if resuming
-    offset = seekPos(fd, 0, SEEK_END);
-    if(offset < 0) {
-      errorCode = ERR_CANNOT_RESUME;
-      ::close(fd);
-      return sftpProtocol::ClientError;                            // client side error
-    }
-    qCDebug(KIO_SFTP_LOG) << "resuming at" << offset;
-  }
-  else {
-    fd = QT_OPEN(QFile::encodeName(dest), O_CREAT | O_TRUNC | O_WRONLY, initialMode);
-  }
-
-  if (fd == -1) {
-    qCDebug(KIO_SFTP_LOG) << "could not write to" << sCopyFile;
-    errorCode = (errno == EACCES) ? ERR_WRITE_ACCESS_DENIED : ERR_CANNOT_OPEN_FOR_WRITING;
-    return sftpProtocol::ClientError;
-  }
-
-  StatusCode result = sftpGet(url, errorCode, offset, fd);
-
-  if( ::close(fd) && result == sftpProtocol::Success ) {
-    errorCode = ERR_COULD_NOT_WRITE;
-    result = sftpProtocol::ClientError;
-  }
-
-  // handle renaming or deletion of a partial file ...
-  if (bMarkPartial) {
-    if (result == sftpProtocol::Success) { // rename ".part" on success
-      if ( !QFile::rename( QFile::encodeName(sPart), sCopyFile ) ) {
-        // If rename fails, try removing the destination first if it exists.
-        if (!bDestExists || !QFile::remove(sCopyFile) || !QFile::rename(sPart, sCopyFile)) {
-            qCDebug(KIO_SFTP_LOG) << "cannot rename " << sPart << " to " << sCopyFile;
-            errorCode = ERR_CANNOT_RENAME_PARTIAL;
-            result = sftpProtocol::ClientError;
+    qCDebug(KIO_SFTP_LOG) << url << "->" << sCopyFile << ", permissions=" << permissions;
+
+    // check if destination is ok ...
+    QT_STATBUF buff;
+    const bool bDestExists = (QT_STAT(QFile::encodeName(sCopyFile), &buff) != -1);
+
+    if(bDestExists)  {
+        if(S_ISDIR(buff.st_mode)) {
+            errorCode = ERR_IS_DIRECTORY;
+            return sftpProtocol::ClientError;
+        }
+
+        if(!(flags & KIO::Overwrite)) {
+            errorCode = ERR_FILE_ALREADY_EXIST;
+            return sftpProtocol::ClientError;
         }
-      }
     }
-    else if (QT_STAT( QFile::encodeName(sPart), &buff ) == 0) { // should a very small ".part" be deleted?
-      const int size = config()->readEntry("MinimumKeepSize", DEFAULT_MINIMUM_KEEP_SIZE);
-      if (buff.st_size <  size)
+
+    bool bResume = false;
+    const QString sPart = sCopyFile + QLatin1String(".part"); // do we have a ".part" file?
+    const bool bPartExists = (QT_STAT(QFile::encodeName(sPart), &buff) != -1);
+    const bool bMarkPartial = config()->readEntry("MarkPartial", true);
+    const QString dest = (bMarkPartial ? sPart : sCopyFile);
+
+    if (bMarkPartial && bPartExists && buff.st_size > 0) {
+        if (S_ISDIR(buff.st_mode)) {
+            errorCode = ERR_DIR_ALREADY_EXIST;
+            return sftpProtocol::ClientError;                            // client side error
+        }
+        bResume = canResume( buff.st_size );
+    }
+
+    if (bPartExists && !bResume)                  // get rid of an unwanted ".part" file
         QFile::remove(sPart);
+
+    // WABA: Make sure that we keep writing permissions ourselves,
+    // otherwise we can be in for a surprise on NFS.
+    mode_t initialMode;
+    if (permissions != -1)
+        initialMode = permissions | S_IWUSR;
+    else
+        initialMode = 0666;
+
+    // open the output file ...
+    int fd = -1;
+    KIO::fileoffset_t offset = 0;
+    if (bResume) {
+        fd = QT_OPEN( QFile::encodeName(sPart), O_RDWR );  // append if resuming
+        offset = seekPos(fd, 0, SEEK_END);
+        if(offset < 0) {
+            errorCode = ERR_CANNOT_RESUME;
+            ::close(fd);
+            return sftpProtocol::ClientError;                            // client side error
+        }
+        qCDebug(KIO_SFTP_LOG) << "resuming at" << offset;
+    }
+    else {
+        fd = QT_OPEN(QFile::encodeName(dest), O_CREAT | O_TRUNC | O_WRONLY, initialMode);
+    }
+
+    if (fd == -1) {
+        qCDebug(KIO_SFTP_LOG) << "could not write to" << sCopyFile;
+        errorCode = (errno == EACCES) ? ERR_WRITE_ACCESS_DENIED : ERR_CANNOT_OPEN_FOR_WRITING;
+        return sftpProtocol::ClientError;
+    }
+
+    StatusCode result = sftpGet(url, errorCode, offset, fd);
+
+    if( ::close(fd) && result == sftpProtocol::Success ) {
+        errorCode = ERR_COULD_NOT_WRITE;
+        result = sftpProtocol::ClientError;
+    }
+
+    // handle renaming or deletion of a partial file ...
+    if (bMarkPartial) {
+        if (result == sftpProtocol::Success) { // rename ".part" on success
+            if ( !QFile::rename( QFile::encodeName(sPart), sCopyFile ) ) {
+                // If rename fails, try removing the destination first if it exists.
+                if (!bDestExists || !QFile::remove(sCopyFile) || !QFile::rename(sPart, sCopyFile)) {
+                    qCDebug(KIO_SFTP_LOG) << "cannot rename " << sPart << " to " << sCopyFile;
+                    errorCode = ERR_CANNOT_RENAME_PARTIAL;
+                    result = sftpProtocol::ClientError;
+                }
+            }
+        }
+        else if (QT_STAT( QFile::encodeName(sPart), &buff ) == 0) { // should a very small ".part" be deleted?
+            const int size = config()->readEntry("MinimumKeepSize", DEFAULT_MINIMUM_KEEP_SIZE);
+            if (buff.st_size <  size)
+                QFile::remove(sPart);
+        }
     }
-  }
 
-  const QString mtimeStr = metaData("modified");
-  if (!mtimeStr.isEmpty()) {
-    QDateTime dt = QDateTime::fromString(mtimeStr, Qt::ISODate);
-    if (dt.isValid()) {
-      struct utimbuf utbuf;
-      utbuf.actime = buff.st_atime; // access time, unchanged
-      utbuf.modtime = dt.toTime_t(); // modification time
-      utime(QFile::encodeName(sCopyFile), &utbuf);
+    const QString mtimeStr = metaData("modified");
+    if (!mtimeStr.isEmpty()) {
+        QDateTime dt = QDateTime::fromString(mtimeStr, Qt::ISODate);
+        if (dt.isValid()) {
+            struct utimbuf utbuf;
+            utbuf.actime = buff.st_atime; // access time, unchanged
+            utbuf.modtime = dt.toTime_t(); // modification time
+            utime(QFile::encodeName(sCopyFile), &utbuf);
+        }
     }
-  }
 
-  return result;
+    return result;
 }
 
 sftpProtocol::StatusCode sftpProtocol::sftpCopyPut(const QUrl& url, const QString& sCopyFile, int permissions, JobFlags flags, int& errorCode)
 {
-  qCDebug(KIO_SFTP_LOG) << sCopyFile << "->" << url << ", permissions=" << permissions << ", flags" << flags;
-
-  // check if source is ok ...
-  QT_STATBUF buff;
-  bool bSrcExists = (QT_STAT(QFile::encodeName(sCopyFile), &buff) != -1);
-
-  if (bSrcExists) {
-    if (S_ISDIR(buff.st_mode)) {
-      errorCode = ERR_IS_DIRECTORY;
-      return sftpProtocol::ClientError;
-    }
-  } else {
-    errorCode = ERR_DOES_NOT_EXIST;
-    return sftpProtocol::ClientError;
-  }
-
-  const int fd = QT_OPEN(QFile::encodeName(sCopyFile), O_RDONLY);
-  if(fd == -1)
-  {
-    errorCode = ERR_CANNOT_OPEN_FOR_READING;
-    return sftpProtocol::ClientError;
-  }
-
-  totalSize(buff.st_size);
-
-  // delegate the real work (errorCode gets status) ...
-  StatusCode ret = sftpPut(url, permissions, flags, errorCode, fd);
-  ::close(fd);
-  return ret;
+    qCDebug(KIO_SFTP_LOG) << sCopyFile << "->" << url << ", permissions=" << permissions << ", flags" << flags;
+
+    // check if source is ok ...
+    QT_STATBUF buff;
+    bool bSrcExists = (QT_STAT(QFile::encodeName(sCopyFile), &buff) != -1);
+
+    if (bSrcExists) {
+        if (S_ISDIR(buff.st_mode)) {
+            errorCode = ERR_IS_DIRECTORY;
+            return sftpProtocol::ClientError;
+        }
+    } else {
+        errorCode = ERR_DOES_NOT_EXIST;
+        return sftpProtocol::ClientError;
+    }
+
+    const int fd = QT_OPEN(QFile::encodeName(sCopyFile), O_RDONLY);
+    if(fd == -1)
+    {
+        errorCode = ERR_CANNOT_OPEN_FOR_READING;
+        return sftpProtocol::ClientError;
+    }
+
+    totalSize(buff.st_size);
+
+    // delegate the real work (errorCode gets status) ...
+    StatusCode ret = sftpPut(url, permissions, flags, errorCode, fd);
+    ::close(fd);
+    return ret;
 }
 
 
 void sftpProtocol::stat(const QUrl& url) {
-  qCDebug(KIO_SFTP_LOG) << url;
+    qCDebug(KIO_SFTP_LOG) << url;
 
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
+    if (!sftpLogin()) {
+        // sftpLogin finished()
+        return;
+    }
 
-  if (url.path().isEmpty() || QDir::isRelativePath(url.path()) ||
-      url.path().contains("/./") || url.path().contains("/../")) {
-    QString cPath;
+    if (url.path().isEmpty() || QDir::isRelativePath(url.path()) ||
+            url.path().contains("/./") || url.path().contains("/../")) {
+        QString cPath;
 
-    if (!url.path().isEmpty()) {
-      cPath = canonicalizePath(url.path());
-    } else {
-      cPath = canonicalizePath(QLatin1String("."));
-    }
+        if (!url.path().isEmpty()) {
+            cPath = canonicalizePath(url.path());
+        } else {
+            cPath = canonicalizePath(QLatin1String("."));
+        }
 
-    if (cPath.isEmpty()) {
-      error(KIO::ERR_MALFORMED_URL, url.toDisplayString());
-      return;
-    }
-    QUrl redir(url);
-    redir.setPath(cPath);
-    redirection(redir);
+        if (cPath.isEmpty()) {
+            error(KIO::ERR_MALFORMED_URL, url.toDisplayString());
+            return;
+        }
+        QUrl redir(url);
+        redir.setPath(cPath);
+        redirection(redir);
 
-    qCDebug(KIO_SFTP_LOG) << "redirecting to " << redir.url();
+        qCDebug(KIO_SFTP_LOG) << "redirecting to " << redir.url();
 
-    finished();
-    return;
-  }
+        finished();
+        return;
+    }
 
-  QByteArray path = url.path().toUtf8();
+    QByteArray path = url.path().toUtf8();
 
-  const QString sDetails = metaData(QLatin1String("details"));
-  const int details = sDetails.isEmpty() ? 2 : sDetails.toInt();
+    const QString sDetails = metaData(QLatin1String("details"));
+    const int details = sDetails.isEmpty() ? 2 : sDetails.toInt();
 
-  UDSEntry entry;
-  entry.clear();
-  if (!createUDSEntry(url.fileName(), path, entry, details)) {
-    error(KIO::ERR_DOES_NOT_EXIST, url.toDisplayString());
-    return;
-  }
+    UDSEntry entry;
+    entry.clear();
+    if (!createUDSEntry(url.fileName(), path, entry, details)) {
+        error(KIO::ERR_DOES_NOT_EXIST, url.toDisplayString());
+        return;
+    }
 
-  statEntry(entry);
+    statEntry(entry);
 
-  finished();
+    finished();
 }
 
 void sftpProtocol::mimetype(const QUrl& url){
-  qCDebug(KIO_SFTP_LOG) << url;
+    qCDebug(KIO_SFTP_LOG) << url;
 
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
+    if (!sftpLogin()) {
+        // sftpLogin finished()
+        return;
+    }
 
-  // open() feeds the mimetype
-  open(url, QIODevice::ReadOnly);
-  // open() finished(), don't finish in close again.
-  closeWithoutFinish();
+    // open() feeds the mimetype
+    open(url, QIODevice::ReadOnly);
+    // open() finished(), don't finish in close again.
+    closeWithoutFinish();
 }
 
 void sftpProtocol::listDir(const QUrl& url) {
-  qCDebug(KIO_SFTP_LOG) << "list directory: " << url;
+    qCDebug(KIO_SFTP_LOG) << "list directory: " << url;
+
+    if (!sftpLogin()) {
+        // sftpLogin finished()
+        return;
+    }
 
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
+    if (url.path().isEmpty() || QDir::isRelativePath(url.path()) ||
+            url.path().contains("/./") || url.path().contains("/../")) {
+        QString cPath;
 
-  if (url.path().isEmpty() || QDir::isRelativePath(url.path()) ||
-      url.path().contains("/./") || url.path().contains("/../")) {
-    QString cPath;
+        if (!url.path().isEmpty() ) {
+            cPath = canonicalizePath(url.path());
+        } else {
+            cPath = canonicalizePath(QStringLiteral("."));
+        }
 
-    if (!url.path().isEmpty() ) {
-      cPath = canonicalizePath(url.path());
-    } else {
-      cPath = canonicalizePath(QStringLiteral("."));
+        if (cPath.isEmpty()) {
+            error(KIO::ERR_MALFORMED_URL, url.toDisplayString());
+            return;
+        }
+        QUrl redir(url);
+        redir.setPath(cPath);
+        redirection(redir);
+
+        qCDebug(KIO_SFTP_LOG) << "redirecting to " << redir.url();
+
+        finished();
+        return;
     }
 
-    if (cPath.isEmpty()) {
-      error(KIO::ERR_MALFORMED_URL, url.toDisplayString());
-      return;
+    QByteArray path = url.path().toUtf8();
+
+    sftp_dir dp = sftp_opendir(mSftp, path.constData());
+    if (dp == nullptr) {
+        reportError(url, sftp_get_error(mSftp));
+        return;
     }
-    QUrl redir(url);
-    redir.setPath(cPath);
-    redirection(redir);
 
-    qCDebug(KIO_SFTP_LOG) << "redirecting to " << redir.url();
+    sftp_attributes dirent = nullptr;
+    const QString sDetails = metaData(QLatin1String("details"));
+    const int details = sDetails.isEmpty() ? 2 : sDetails.toInt();
+    UDSEntry entry;
 
-    finished();
-    return;
-  }
+    qCDebug(KIO_SFTP_LOG) << "readdir: " << path << ", details: " << QString::number(details);
 
-  QByteArray path = url.path().toUtf8();
+    for (;;) {
+        mode_t access;
+        char *link;
+        bool isBrokenLink = false;
+        long long fileType = S_IFREG;
+        long long size = 0LL;
 
-  sftp_dir dp = sftp_opendir(mSftp, path.constData());
-  if (dp == nullptr) {
-    reportError(url, sftp_get_error(mSftp));
-    return;
-  }
+        dirent = sftp_readdir(mSftp, dp);
+        if (dirent == nullptr) {
+            break;
+        }
 
-  sftp_attributes dirent = nullptr;
-  const QString sDetails = metaData(QLatin1String("details"));
-  const int details = sDetails.isEmpty() ? 2 : sDetails.toInt();
-  UDSEntry entry;
+        entry.clear();
+        entry.fastInsert(KIO::UDSEntry::UDS_NAME, QFile::decodeName(dirent->name));
 
-  qCDebug(KIO_SFTP_LOG) << "readdir: " << path << ", details: " << QString::number(details);
+        if (dirent->type == SSH_FILEXFER_TYPE_SYMLINK) {
+            QByteArray file = path + '/' + QFile::decodeName(dirent->name).toUtf8();
 
-  for (;;) {
-    mode_t access;
-    char *link;
-    bool isBrokenLink = false;
-    long long fileType = S_IFREG;
-    long long size = 0LL;
+            link = sftp_readlink(mSftp, file.constData());
+            if (link == nullptr) {
+                sftp_attributes_free(dirent);
+                error(KIO::ERR_INTERNAL, i18n("Could not read link: %1", QString::fromUtf8(file)));
+                return;
+            }
+            entry.fastInsert(KIO::UDSEntry::UDS_LINK_DEST, QFile::decodeName(link));
+            free(link);
+            // A symlink -> follow it only if details > 1
+            if (details > 1) {
+                sftp_attributes sb = sftp_stat(mSftp, file.constData());
+                if (sb == nullptr) {
+                    isBrokenLink = true;
+                } else {
+                    sftp_attributes_free(dirent);
+                    dirent = sb;
+                }
+            }
+        }
 
-    dirent = sftp_readdir(mSftp, dp);
-    if (dirent == nullptr) {
-      break;
-    }
+        if (isBrokenLink) {
+            // It is a link pointing to nowhere
+            fileType = S_IFMT - 1;
+            access = S_IRWXU | S_IRWXG | S_IRWXO;
+            size = 0LL;
+        } else {
+            switch (dirent->type) {
+            case SSH_FILEXFER_TYPE_REGULAR:
+                fileType = S_IFREG;
+                break;
+            case SSH_FILEXFER_TYPE_DIRECTORY:
+                fileType = S_IFDIR;
+                break;
+            case SSH_FILEXFER_TYPE_SYMLINK:
+                fileType = S_IFLNK;
+                break;
+            case SSH_FILEXFER_TYPE_SPECIAL:
+            case SSH_FILEXFER_TYPE_UNKNOWN:
+                break;
+            }
 
-    entry.clear();
-    entry.fastInsert(KIO::UDSEntry::UDS_NAME, QFile::decodeName(dirent->name));
+            access = dirent->permissions & 07777;
+            size = dirent->size;
+        }
+        entry.fastInsert(KIO::UDSEntry::UDS_FILE_TYPE, fileType);
+        entry.fastInsert(KIO::UDSEntry::UDS_ACCESS, access);
+        entry.fastInsert(KIO::UDSEntry::UDS_SIZE, size);
+
+        if (details > 0) {
+            if (dirent->owner) {
+                entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::fromUtf8(dirent->owner));
+            } else {
+                entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::number(dirent->uid));
+            }
 
-    if (dirent->type == SSH_FILEXFER_TYPE_SYMLINK) {
-      QByteArray file = path + '/' + QFile::decodeName(dirent->name).toUtf8();
+            if (dirent->group) {
+                entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::fromUtf8(dirent->group));
+            } else {
+                entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::number(dirent->gid));
+            }
+
+            entry.fastInsert(KIO::UDSEntry::UDS_ACCESS_TIME, dirent->atime);
+            entry.fastInsert(KIO::UDSEntry::UDS_MODIFICATION_TIME, dirent->mtime);
+            entry.fastInsert(KIO::UDSEntry::UDS_CREATION_TIME, dirent->createtime);
+        }
 
-      link = sftp_readlink(mSftp, file.constData());
-      if (link == nullptr) {
         sftp_attributes_free(dirent);
-        error(KIO::ERR_INTERNAL, i18n("Could not read link: %1", QString::fromUtf8(file)));
+        listEntry(entry);
+    } // for ever
+    sftp_closedir(dp);
+    finished();
+}
+
+void sftpProtocol::mkdir(const QUrl &url, int permissions) {
+    qCDebug(KIO_SFTP_LOG) << "create directory: " << url;
+
+    if (!sftpLogin()) {
+        // sftpLogin finished()
         return;
-      }
-      entry.fastInsert(KIO::UDSEntry::UDS_LINK_DEST, QFile::decodeName(link));
-      free(link);
-      // A symlink -> follow it only if details > 1
-      if (details > 1) {
-        sftp_attributes sb = sftp_stat(mSftp, file.constData());
-        if (sb == nullptr) {
-          isBrokenLink = true;
-        } else {
-          sftp_attributes_free(dirent);
-          dirent = sb;
-        }
-      }
     }
 
-    if (isBrokenLink) {
-      // It is a link pointing to nowhere
-      fileType = S_IFMT - 1;
-      access = S_IRWXU | S_IRWXG | S_IRWXO;
-      size = 0LL;
-    } else {
-      switch (dirent->type) {
-        case SSH_FILEXFER_TYPE_REGULAR:
-          fileType = S_IFREG;
-          break;
-        case SSH_FILEXFER_TYPE_DIRECTORY:
-          fileType = S_IFDIR;
-          break;
-        case SSH_FILEXFER_TYPE_SYMLINK:
-          fileType = S_IFLNK;
-          break;
-        case SSH_FILEXFER_TYPE_SPECIAL:
-        case SSH_FILEXFER_TYPE_UNKNOWN:
-          break;
-      }
+    if (url.path().isEmpty()) {
+        error(KIO::ERR_MALFORMED_URL, url.toDisplayString());
+        return;
+    }
+    const QString path = url.path();
+    const QByteArray path_c = path.toUtf8();
 
-      access = dirent->permissions & 07777;
-      size = dirent->size;
+    // Remove existing file or symlink, if requested.
+    if (metaData(QLatin1String("overwrite")) == QLatin1String("true")) {
+        qCDebug(KIO_SFTP_LOG) << "overwrite set, remove existing file or symlink: " << url;
+        sftp_unlink(mSftp, path_c.constData());
     }
-    entry.fastInsert(KIO::UDSEntry::UDS_FILE_TYPE, fileType);
-    entry.fastInsert(KIO::UDSEntry::UDS_ACCESS, access);
-    entry.fastInsert(KIO::UDSEntry::UDS_SIZE, size);
 
-    if (details > 0) {
-      if (dirent->owner) {
-          entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::fromUtf8(dirent->owner));
-      } else {
-          entry.fastInsert(KIO::UDSEntry::UDS_USER, QString::number(dirent->uid));
-      }
-
-      if (dirent->group) {
-          entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::fromUtf8(dirent->group));
-      } else {
-          entry.fastInsert(KIO::UDSEntry::UDS_GROUP, QString::number(dirent->gid));
-      }
-
-      entry.fastInsert(KIO::UDSEntry::UDS_ACCESS_TIME, dirent->atime);
-      entry.fastInsert(KIO::UDSEntry::UDS_MODIFICATION_TIME, dirent->mtime);
-      entry.fastInsert(KIO::UDSEntry::UDS_CREATION_TIME, dirent->createtime);
-    }
-
-    sftp_attributes_free(dirent);
-    listEntry(entry);
-  } // for ever
-  sftp_closedir(dp);
-  finished();
-}
+    qCDebug(KIO_SFTP_LOG) << "Trying to create directory: " << path;
+    sftp_attributes sb = sftp_lstat(mSftp, path_c.constData());
+    if (sb == nullptr) {
+        if (sftp_mkdir(mSftp, path_c.constData(), 0777) < 0) {
+            reportError(url, sftp_get_error(mSftp));
+            sftp_attributes_free(sb);
+            return;
+        }
 
-void sftpProtocol::mkdir(const QUrl &url, int permissions) {
-  qCDebug(KIO_SFTP_LOG) << "create directory: " << url;
-
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
-
-  if (url.path().isEmpty()) {
-    error(KIO::ERR_MALFORMED_URL, url.toDisplayString());
-    return;
-  }
-  const QString path = url.path();
-  const QByteArray path_c = path.toUtf8();
-
-  // Remove existing file or symlink, if requested.
-  if (metaData(QLatin1String("overwrite")) == QLatin1String("true")) {
-    qCDebug(KIO_SFTP_LOG) << "overwrite set, remove existing file or symlink: " << url;
-    sftp_unlink(mSftp, path_c.constData());
-  }
-
-  qCDebug(KIO_SFTP_LOG) << "Trying to create directory: " << path;
-  sftp_attributes sb = sftp_lstat(mSftp, path_c.constData());
-  if (sb == nullptr) {
-    if (sftp_mkdir(mSftp, path_c.constData(), 0777) < 0) {
-      reportError(url, sftp_get_error(mSftp));
-      sftp_attributes_free(sb);
-      return;
-    }
-
-    qCDebug(KIO_SFTP_LOG) << "Successfully created directory: " << url;
-    if (permissions != -1) {
-      // This will report an error or finished.
-      chmod(url, permissions);
-    } else {
-      finished();
+        qCDebug(KIO_SFTP_LOG) << "Successfully created directory: " << url;
+        if (permissions != -1) {
+            // This will report an error or finished.
+            chmod(url, permissions);
+        } else {
+            finished();
+        }
+
+        sftp_attributes_free(sb);
+        return;
     }
 
+    auto err = KSFTP_ISDIR(sb) ? KIO::ERR_DIR_ALREADY_EXIST : KIO::ERR_FILE_ALREADY_EXIST;
     sftp_attributes_free(sb);
-    return;
-  }
-
-  auto err = KSFTP_ISDIR(sb) ? KIO::ERR_DIR_ALREADY_EXIST : KIO::ERR_FILE_ALREADY_EXIST;
-  sftp_attributes_free(sb);
-  error(err, path);
+    error(err, path);
 }
 
 void sftpProtocol::rename(const QUrl& src, const QUrl& dest, KIO::JobFlags flags) {
-  qCDebug(KIO_SFTP_LOG) << "rename " << src << " to " << dest << flags;
+    qCDebug(KIO_SFTP_LOG) << "rename " << src << " to " << dest << flags;
 
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
+    if (!sftpLogin()) {
+        // sftpLogin finished()
+        return;
+    }
 
-  QByteArray qsrc = src.path().toUtf8();
-  QByteArray qdest = dest.path().toUtf8();
+    QByteArray qsrc = src.path().toUtf8();
+    QByteArray qdest = dest.path().toUtf8();
 
-  sftp_attributes sb = sftp_lstat(mSftp, qdest.constData());
-  if (sb != nullptr) {
-    const bool isDir = KSFTP_ISDIR(sb);
-    if (!(flags & KIO::Overwrite)) {
-      error(isDir ? KIO::ERR_DIR_ALREADY_EXIST : KIO::ERR_FILE_ALREADY_EXIST, dest.url());
-      sftp_attributes_free(sb);
-      return;
+    sftp_attributes sb = sftp_lstat(mSftp, qdest.constData());
+    if (sb != nullptr) {
+        const bool isDir = KSFTP_ISDIR(sb);
+        if (!(flags & KIO::Overwrite)) {
+            error(isDir ? KIO::ERR_DIR_ALREADY_EXIST : KIO::ERR_FILE_ALREADY_EXIST, dest.url());
+            sftp_attributes_free(sb);
+            return;
+        }
+
+        // Delete the existing destination file/dir...
+        if (isDir) {
+            if (sftp_rmdir(mSftp, qdest.constData()) < 0) {
+                reportError(dest, sftp_get_error(mSftp));
+                return;
+            }
+        } else {
+            if (sftp_unlink(mSftp, qdest.constData()) < 0) {
+                reportError(dest, sftp_get_error(mSftp));
+                return;
+            }
+        }
     }
+    sftp_attributes_free(sb);
 
-    // Delete the existing destination file/dir...
-    if (isDir) {
-      if (sftp_rmdir(mSftp, qdest.constData()) < 0) {
+    if (sftp_rename(mSftp, qsrc.constData(), qdest.constData()) < 0) {
         reportError(dest, sftp_get_error(mSftp));
         return;
-      }
-    } else {
-      if (sftp_unlink(mSftp, qdest.constData()) < 0) {
-        reportError(dest, sftp_get_error(mSftp));
-        return;
-      }
     }
-  }
-  sftp_attributes_free(sb);
 
-  if (sftp_rename(mSftp, qsrc.constData(), qdest.constData()) < 0) {
-    reportError(dest, sftp_get_error(mSftp));
-    return;
-  }
-
-  finished();
+    finished();
 }
 
 void sftpProtocol::symlink(const QString &target, const QUrl &dest, KIO::JobFlags flags) {
-  qCDebug(KIO_SFTP_LOG) << "link " << target << "->" << dest
-                      << ", overwrite = " << (flags & KIO::Overwrite)
-                      << ", resume = " << (flags & KIO::Resume);
-
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
-
-  QByteArray t = target.toUtf8();
-  QByteArray d = dest.path().toUtf8();
-
-  bool failed = false;
-  if (sftp_symlink(mSftp, t.constData(), d.constData()) < 0) {
-    if (flags == KIO::Overwrite) {
-      sftp_attributes sb = sftp_lstat(mSftp, d.constData());
-      if (sb == nullptr) {
-        failed = true;
-      } else {
-        if (sftp_unlink(mSftp, d.constData()) < 0) {
-          failed = true;
-        } else {
-          if (sftp_symlink(mSftp, t.constData(), d.constData()) < 0) {
-            failed = true;
-          }
+    qCDebug(KIO_SFTP_LOG) << "link " << target << "->" << dest
+                          << ", overwrite = " << (flags & KIO::Overwrite)
+                          << ", resume = " << (flags & KIO::Resume);
+
+    if (!sftpLogin()) {
+        // sftpLogin finished()
+        return;
+    }
+
+    QByteArray t = target.toUtf8();
+    QByteArray d = dest.path().toUtf8();
+
+    bool failed = false;
+    if (sftp_symlink(mSftp, t.constData(), d.constData()) < 0) {
+        if (flags == KIO::Overwrite) {
+            sftp_attributes sb = sftp_lstat(mSftp, d.constData());
+            if (sb == nullptr) {
+                failed = true;
+            } else {
+                if (sftp_unlink(mSftp, d.constData()) < 0) {
+                    failed = true;
+                } else {
+                    if (sftp_symlink(mSftp, t.constData(), d.constData()) < 0) {
+                        failed = true;
+                    }
+                }
+            }
+            sftp_attributes_free(sb);
         }
-      }
-      sftp_attributes_free(sb);
     }
-  }
 
-  if (failed) {
-    reportError(dest, sftp_get_error(mSftp));
-    return;
-  }
+    if (failed) {
+        reportError(dest, sftp_get_error(mSftp));
+        return;
+    }
 
-  finished();
+    finished();
 }
 
 void sftpProtocol::chmod(const QUrl& url, int permissions) {
-  qCDebug(KIO_SFTP_LOG) << "change permission of " << url << " to " << QString::number(permissions);
+    qCDebug(KIO_SFTP_LOG) << "change permission of " << url << " to " << QString::number(permissions);
 
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
+    if (!sftpLogin()) {
+        // sftpLogin finished()
+        return;
+    }
 
-  QByteArray path = url.path().toUtf8();
+    QByteArray path = url.path().toUtf8();
 
-  if (sftp_chmod(mSftp, path.constData(), permissions) < 0) {
-    reportError(url, sftp_get_error(mSftp));
-    return;
-  }
+    if (sftp_chmod(mSftp, path.constData(), permissions) < 0) {
+        reportError(url, sftp_get_error(mSftp));
+        return;
+    }
 
-  finished();
+    finished();
 }
 
 void sftpProtocol::del(const QUrl &url, bool isfile){
-  qCDebug(KIO_SFTP_LOG) << "deleting " << (isfile ? "file: " : "directory: ") << url;
+    qCDebug(KIO_SFTP_LOG) << "deleting " << (isfile ? "file: " : "directory: ") << url;
 
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
+    if (!sftpLogin()) {
+        // sftpLogin finished()
+        return;
+    }
 
-  QByteArray path = url.path().toUtf8();
+    QByteArray path = url.path().toUtf8();
 
-  if (isfile) {
-    if (sftp_unlink(mSftp, path.constData()) < 0) {
-      reportError(url, sftp_get_error(mSftp));
-      return;
-    }
-  } else {
-    if (sftp_rmdir(mSftp, path.constData()) < 0) {
-      reportError(url, sftp_get_error(mSftp));
-      return;
+    if (isfile) {
+        if (sftp_unlink(mSftp, path.constData()) < 0) {
+            reportError(url, sftp_get_error(mSftp));
+            return;
+        }
+    } else {
+        if (sftp_rmdir(mSftp, path.constData()) < 0) {
+            reportError(url, sftp_get_error(mSftp));
+            return;
+        }
     }
-  }
 
-  finished();
+    finished();
 }
 
 void sftpProtocol::slave_status() {
-  qCDebug(KIO_SFTP_LOG) << "connected to " << mHost << "?: " << mConnected;
-  slaveStatus((mConnected ? mHost : QString()), mConnected);
+    qCDebug(KIO_SFTP_LOG) << "connected to " << mHost << "?: " << mConnected;
+    slaveStatus((mConnected ? mHost : QString()), mConnected);
 }
 
 sftpProtocol::GetRequest::GetRequest(sftp_file file, sftp_attributes sb, ushort maxPendingRequests)
@@ -2109,117 +2109,117 @@ sftpProtocol::GetRequest::GetRequest(sftp_file file, sftp_attributes sb, ushort
 }
 
 bool sftpProtocol::GetRequest::enqueueChunks() {
-  sftpProtocol::GetRequest::Request request;
-
-  qCDebug(KIO_SFTP_LOG) << "enqueueChunks";
-
-  while (pendingRequests.count() < mMaxPendingRequests) {
-    request.expectedLength = MAX_XFER_BUF_SIZE;
-    request.startOffset = mFile->offset;
-    request.id = sftp_async_read_begin(mFile, request.expectedLength);
-    if (request.id < 0) {
-      if (pendingRequests.isEmpty()) {
-        return false;
-      } else {
-          break;
-      }
-    }
+    sftpProtocol::GetRequest::Request request;
+
+    qCDebug(KIO_SFTP_LOG) << "enqueueChunks";
+
+    while (pendingRequests.count() < mMaxPendingRequests) {
+        request.expectedLength = MAX_XFER_BUF_SIZE;
+        request.startOffset = mFile->offset;
+        request.id = sftp_async_read_begin(mFile, request.expectedLength);
+        if (request.id < 0) {
+            if (pendingRequests.isEmpty()) {
+                return false;
+            } else {
+                break;
+            }
+        }
 
-    pendingRequests.enqueue(request);
+        pendingRequests.enqueue(request);
 
-    if (mFile->offset >= mSb->size) {
-      // Do not add any more chunks if the offset is larger than the given file size.
-      // However this is done after adding a request as the remote file size may
-      // have changed in the meantime.
-      break;
+        if (mFile->offset >= mSb->size) {
+            // Do not add any more chunks if the offset is larger than the given file size.
+            // However this is done after adding a request as the remote file size may
+            // have changed in the meantime.
+            break;
+        }
     }
-  }
 
-  qCDebug(KIO_SFTP_LOG) << "enqueueChunks done" << QString::number(pendingRequests.size());
+    qCDebug(KIO_SFTP_LOG) << "enqueueChunks done" << QString::number(pendingRequests.size());
 
-  return true;
+    return true;
 }
 
 int sftpProtocol::GetRequest::readChunks(QByteArray &data) {
 
-  int totalRead = 0;
-  ssize_t bytesread = 0;
+    int totalRead = 0;
+    ssize_t bytesread = 0;
 
-  while (!pendingRequests.isEmpty()) {
-    sftpProtocol::GetRequest::Request &request = pendingRequests.head();
-    int dataSize = data.size() + request.expectedLength;
+    while (!pendingRequests.isEmpty()) {
+        sftpProtocol::GetRequest::Request &request = pendingRequests.head();
+        int dataSize = data.size() + request.expectedLength;
 
-    data.resize(dataSize);
-    if (data.size() < dataSize) {
-      // Could not allocate enough memory - skip current chunk
-      data.resize(dataSize - request.expectedLength);
-      break;
-    }
+        data.resize(dataSize);
+        if (data.size() < dataSize) {
+            // Could not allocate enough memory - skip current chunk
+            data.resize(dataSize - request.expectedLength);
+            break;
+        }
 
-    bytesread = sftp_async_read(mFile, data.data() + totalRead, request.expectedLength, request.id);
+        bytesread = sftp_async_read(mFile, data.data() + totalRead, request.expectedLength, request.id);
 
-    // qCDebug(KIO_SFTP_LOG) << "bytesread=" << QString::number(bytesread);
+        // qCDebug(KIO_SFTP_LOG) << "bytesread=" << QString::number(bytesread);
 
-    if (bytesread == 0 || bytesread == SSH_AGAIN) {
-      // Done reading or timeout
-      data.resize(data.size() - request.expectedLength);
+        if (bytesread == 0 || bytesread == SSH_AGAIN) {
+            // Done reading or timeout
+            data.resize(data.size() - request.expectedLength);
 
-      if (bytesread == 0) {
-        pendingRequests.dequeue(); // This frees QByteArray &data!
-      }
+            if (bytesread == 0) {
+                pendingRequests.dequeue(); // This frees QByteArray &data!
+            }
 
-      break;
-    } else if (bytesread == SSH_ERROR) {
-      return -1;
-    }
+            break;
+        } else if (bytesread == SSH_ERROR) {
+            return -1;
+        }
 
-    totalRead += bytesread;
+        totalRead += bytesread;
 
-    if (bytesread < request.expectedLength) {
-      int rc;
+        if (bytesread < request.expectedLength) {
+            int rc;
 
-      // If less data is read than expected - requeue the request
-      data.resize(data.size() - (request.expectedLength - bytesread));
+            // If less data is read than expected - requeue the request
+            data.resize(data.size() - (request.expectedLength - bytesread));
 
-      // Modify current request
-      request.expectedLength -= bytesread;
-      request.startOffset += bytesread;
+            // Modify current request
+            request.expectedLength -= bytesread;
+            request.startOffset += bytesread;
 
-      rc = sftp_seek64(mFile, request.startOffset);
-      if (rc < 0) {
-        // Failed to continue reading
-        return -1;
-      }
+            rc = sftp_seek64(mFile, request.startOffset);
+            if (rc < 0) {
+                // Failed to continue reading
+                return -1;
+            }
 
-      request.id = sftp_async_read_begin(mFile, request.expectedLength);
+            request.id = sftp_async_read_begin(mFile, request.expectedLength);
 
-      if (request.id < 0) {
-        // Failed to dispatch rerequest
-        return -1;
-      }
+            if (request.id < 0) {
+                // Failed to dispatch rerequest
+                return -1;
+            }
 
-      return totalRead;
-    }
+            return totalRead;
+        }
 
-    pendingRequests.dequeue();
-  }
+        pendingRequests.dequeue();
+    }
 
-  return totalRead;
+    return totalRead;
 }
 
 sftpProtocol::GetRequest::~GetRequest() {
-  sftpProtocol::GetRequest::Request request;
-  char buf[MAX_XFER_BUF_SIZE];
-
-  // Remove pending reads to avoid memory leaks
-  while (!pendingRequests.isEmpty()) {
-    request = pendingRequests.dequeue();
-    sftp_async_read(mFile, buf, request.expectedLength, request.id);
-  }
-
-  // Close channel & free attributes
-  sftp_close(mFile);
-  sftp_attributes_free(mSb);
+    sftpProtocol::GetRequest::Request request;
+    char buf[MAX_XFER_BUF_SIZE];
+
+    // Remove pending reads to avoid memory leaks
+    while (!pendingRequests.isEmpty()) {
+        request = pendingRequests.dequeue();
+        sftp_async_read(mFile, buf, request.expectedLength, request.id);
+    }
+
+    // Close channel & free attributes
+    sftp_close(mFile);
+    sftp_attributes_free(mSb);
 }
 
 void sftpProtocol::requiresUserNameRedirection()
@@ -2251,55 +2251,55 @@ bool sftpProtocol::sftpLogin()
 
 void sftpProtocol::sftpSendWarning(int errorCode, const QString& url)
 {
-  switch (errorCode) {
-  case -1:
-      warning(i18n( "Could not change permissions for\n%1", url));
-      break;
-  default:
-      break;
-  }
+    switch (errorCode) {
+    case -1:
+        warning(i18n( "Could not change permissions for\n%1", url));
+        break;
+    default:
+        break;
+    }
 }
 
 void sftpProtocol::closeWithoutFinish()
 {
-  sftp_close(mOpenFile);
-  mOpenFile = nullptr;
+    sftp_close(mOpenFile);
+    mOpenFile = nullptr;
 }
 
 void sftpProtocol::clearPubKeyAuthInfo()
 {
-  if (mPublicKeyAuthInfo) {
-      delete mPublicKeyAuthInfo;
-      mPublicKeyAuthInfo = nullptr;
-  }
+    if (mPublicKeyAuthInfo) {
+        delete mPublicKeyAuthInfo;
+        mPublicKeyAuthInfo = nullptr;
+    }
 }
 
 void sftpProtocol::fileSystemFreeSpace(const QUrl& url)
 {
-  qCDebug(KIO_SFTP_LOG) << "file system free space of" << url;
+    qCDebug(KIO_SFTP_LOG) << "file system free space of" << url;
 
-  if (!sftpLogin()) {
-    // sftpLogin finished()
-    return;
-  }
+    if (!sftpLogin()) {
+        // sftpLogin finished()
+        return;
+    }
 
-  if (sftp_extension_supported(mSftp, "statvfs@openssh.com", "2") == 0) {
-    error(ERR_UNSUPPORTED_ACTION, QString());
-    return;
-  }
+    if (sftp_extension_supported(mSftp, "statvfs@openssh.com", "2") == 0) {
+        error(ERR_UNSUPPORTED_ACTION, QString());
+        return;
+    }
 
-  const QByteArray path = url.path().toUtf8();
+    const QByteArray path = url.path().toUtf8();
 
-  sftp_statvfs_t statvfs = sftp_statvfs(mSftp, path.constData());
-  if (statvfs == nullptr) {
-    reportError(url, sftp_get_error(mSftp));
-    return;
-  }
+    sftp_statvfs_t statvfs = sftp_statvfs(mSftp, path.constData());
+    if (statvfs == nullptr) {
+        reportError(url, sftp_get_error(mSftp));
+        return;
+    }
 
-  setMetaData(QString::fromLatin1("total"), QString::number(statvfs->f_frsize * statvfs->f_blocks));
-  setMetaData(QString::fromLatin1("available"), QString::number(statvfs->f_frsize * statvfs->f_bavail));
+    setMetaData(QString::fromLatin1("total"), QString::number(statvfs->f_frsize * statvfs->f_blocks));
+    setMetaData(QString::fromLatin1("available"), QString::number(statvfs->f_frsize * statvfs->f_bavail));
 
-  sftp_statvfs_free(statvfs);
+    sftp_statvfs_free(statvfs);
 
-  finished();
+    finished();
 }
-- 
2.19.1


From 21019c882d27f1cdf91b19ef9f8e4d3a8e343c58 Mon Sep 17 00:00:00 2001
From: Andreas Schneider <asn@cryptomilk.org>
Date: Sun, 2 Sep 2018 16:25:31 +0200
Subject: [PATCH 19/22] [sftp] Use Q_ASSERT in sftpProtocol::reportError()

BUG: 362988

Signed-off-by: Andreas Schneider <asn@cryptomilk.org>
---
 sftp/kio_sftp.cpp | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 8b215011..24e3e05d 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -333,8 +333,9 @@ void sftpProtocol::reportError(const QUrl &url, const int err) {
     qCDebug(KIO_SFTP_LOG) << "url = " << url << " - err=" << err;
 
     const int kioError = toKIOError(err);
-    if (kioError)
-        error(kioError, url.toDisplayString());
+    Q_ASSERT(kioError != 0);
+
+    error(kioError, url.toDisplayString());
 }
 
 bool sftpProtocol::createUDSEntry(const QString &filename, const QByteArray &path,
-- 
2.19.1


From c13c91e4c80f1f43c9538c802362be91dc7953cb Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Wed, 24 Oct 2018 16:09:16 +0200
Subject: [PATCH 20/22] [sftp] also change header to 4 space indentation

brings it in line with the cpp after
972b5f5ef074e136aad27eaceb2b968651bdc31e where I've forgotten to update the
header :S
---
 sftp/kio_sftp.h | 284 ++++++++++++++++++++++++------------------------
 1 file changed, 141 insertions(+), 143 deletions(-)

diff --git a/sftp/kio_sftp.h b/sftp/kio_sftp.h
index 590670ba..69f06430 100644
--- a/sftp/kio_sftp.h
+++ b/sftp/kio_sftp.h
@@ -32,190 +32,188 @@
 #include <QtCore/QQueue>
 
 namespace KIO {
-  class AuthInfo;
+class AuthInfo;
 }
 
 class sftpProtocol : public KIO::SlaveBase
 {
-
 public:
-  sftpProtocol(const QByteArray &pool_socket, const QByteArray &app_socket);
-  ~sftpProtocol() override;
-  void setHost(const QString &h, quint16 port, const QString& user, const QString& pass) override;
-  void get(const QUrl &url) override;
-  void listDir(const QUrl &url) override ;
-  void mimetype(const QUrl &url) override;
-  void stat(const QUrl &url) override;
-  void copy(const QUrl &src, const QUrl &dest, int permissions, KIO::JobFlags flags) override;
-  void put(const QUrl &url, int permissions, KIO::JobFlags flags) override;
-  void closeConnection() override;
-  void slave_status() override;
-  void del(const QUrl &url, bool isfile) override;
-  void chmod(const QUrl &url, int permissions) override;
-  void symlink(const QString &target, const QUrl &dest, KIO::JobFlags flags) override;
-  void rename(const QUrl &src, const QUrl &dest, KIO::JobFlags flags) override;
-  void mkdir(const QUrl &url, int permissions) override;
-  void openConnection() override;
-
-  // KIO::FileJob interface
-  void open(const QUrl &url, QIODevice::OpenMode mode) override;
-  void read(KIO::filesize_t size) override;
-  void write(const QByteArray &data) override;
-  void seek(KIO::filesize_t offset) override;
-  void close() override;
-  void special(const QByteArray &data) override;
-
-  // libssh authentication callback (note that this is called by the
-  // global ::auth_callback() call.
-  int auth_callback(const char *prompt, char *buf, size_t len,
-    int echo, int verify, void *userdata);
-
-  // libssh logging callback (note that this is called by the
-  // global ::log_callback() call.
-  void log_callback(int priority, const char *function, const char *buffer,
-                    void *userdata);
+    sftpProtocol(const QByteArray &pool_socket, const QByteArray &app_socket);
+    ~sftpProtocol() override;
+    void setHost(const QString &h, quint16 port, const QString& user, const QString& pass) override;
+    void get(const QUrl &url) override;
+    void listDir(const QUrl &url) override ;
+    void mimetype(const QUrl &url) override;
+    void stat(const QUrl &url) override;
+    void copy(const QUrl &src, const QUrl &dest, int permissions, KIO::JobFlags flags) override;
+    void put(const QUrl &url, int permissions, KIO::JobFlags flags) override;
+    void closeConnection() override;
+    void slave_status() override;
+    void del(const QUrl &url, bool isfile) override;
+    void chmod(const QUrl &url, int permissions) override;
+    void symlink(const QString &target, const QUrl &dest, KIO::JobFlags flags) override;
+    void rename(const QUrl &src, const QUrl &dest, KIO::JobFlags flags) override;
+    void mkdir(const QUrl &url, int permissions) override;
+    void openConnection() override;
+
+    // KIO::FileJob interface
+    void open(const QUrl &url, QIODevice::OpenMode mode) override;
+    void read(KIO::filesize_t size) override;
+    void write(const QByteArray &data) override;
+    void seek(KIO::filesize_t offset) override;
+    void close() override;
+    void special(const QByteArray &data) override;
+
+    // libssh authentication callback (note that this is called by the
+    // global ::auth_callback() call.
+    int auth_callback(const char *prompt, char *buf, size_t len,
+                      int echo, int verify, void *userdata);
+
+    // libssh logging callback (note that this is called by the
+    // global ::log_callback() call.
+    void log_callback(int priority, const char *function, const char *buffer,
+                      void *userdata);
 
 protected:
-  void virtual_hook(int id, void *data) override;
+    void virtual_hook(int id, void *data) override;
 
 private: // Private variables
-  /** True if ioslave is connected to sftp server. */
-  bool mConnected;
+    /** True if ioslave is connected to sftp server. */
+    bool mConnected;
 
-  /** Host we are connected to. */
-  QString mHost;
+    /** Host we are connected to. */
+    QString mHost;
 
-  /** Port we are connected to. */
-  int mPort;
+    /** Port we are connected to. */
+    int mPort;
 
-  /** The ssh session for the connection */
-  ssh_session mSession;
+    /** The ssh session for the connection */
+    ssh_session mSession;
 
-  /** The sftp session for the connection */
-  sftp_session mSftp;
+    /** The sftp session for the connection */
+    sftp_session mSftp;
 
-  /** Username to use when connecting */
-  QString mUsername;
+    /** Username to use when connecting */
+    QString mUsername;
 
-  /** User's password */
-  QString mPassword;
+    /** User's password */
+    QString mPassword;
 
-  /** The open file */
-  sftp_file mOpenFile;
+    /** The open file */
+    sftp_file mOpenFile;
 
-  /** The open URL */
-  QUrl mOpenUrl;
+    /** The open URL */
+    QUrl mOpenUrl;
 
-  ssh_callbacks mCallbacks;
+    ssh_callbacks mCallbacks;
 
-  /** Version of the sftp protocol we are using. */
-  int sftpVersion;
+    /** Version of the sftp protocol we are using. */
+    int sftpVersion;
 
-  struct Status
-  {
-    int code;
-    KIO::filesize_t size;
-    QString text;
-  };
+    struct Status
+    {
+        int code;
+        KIO::filesize_t size;
+        QString text;
+    };
 
-  // KIO::FileJob interface
-  /** The opened handle */
-  QByteArray openHandle;
-  QUrl openUrl;
-  KIO::filesize_t openOffset;
+    // KIO::FileJob interface
+    /** The opened handle */
+    QByteArray openHandle;
+    QUrl openUrl;
+    KIO::filesize_t openOffset;
 
-  /**
+    /**
    * Holds public key authentication info for proper retry handling.
    */
-  KIO::AuthInfo* mPublicKeyAuthInfo;
-
-  /**
-   * GetRequest encapsulates several SFTP get requests into a single object.
-   * As SFTP messages are limited to MAX_XFER_BUF_SIZE several requests
-   * should be sent simultaneously in order to increase transfer speeds.
-   */
-  class GetRequest {
-  public:
-    /**
-     * Creates a new GetRequest object.
-     * @param file the sftp_file object which should be transferred.
-     * @param sb the attributes of that sftp_file object.
-     * @param maxPendingRequests the maximum number of parallel requests to start with.
-     *                           The more are pending the higher the potential memory
-     *                           foot print, however if the connection allows it
-     *                           we'll get better throughput.
-     */
-    GetRequest(sftp_file file, sftp_attributes sb, ushort maxPendingRequests = 128);
-    /**
-     * Removes all pending requests and closes the SFTP channel and attributes
-     * in order to avoid memory leaks.
-     */
-    ~GetRequest();
+    KIO::AuthInfo* mPublicKeyAuthInfo;
 
     /**
-     * Starts up to maxPendingRequests file requests. Reading is performed in the
-     * via the readChunks method.
-     */
-    bool enqueueChunks();
-    /**
-     * Attemps to read all pending chunks in the given QByteArray.
-     * @param data the array into which the data should be saved (it should be empty).
-     * @return 0 on EOF or timeout, -1 on error and the number of bytes read otherwise.
+     * GetRequest encapsulates several SFTP get requests into a single object.
+     * As SFTP messages are limited to MAX_XFER_BUF_SIZE several requests
+     * should be sent simultaneously in order to increase transfer speeds.
      */
-    int readChunks(QByteArray &data);
-  private:
-    struct Request {
-      /** Identifier as returned by the sftp_async_read_begin call */
-      int id;
-      /** The number of bytes expected to be returned */
-      uint32_t expectedLength;
-      /** The SSH start offset when this request was made */
-      uint64_t startOffset;
+    class GetRequest {
+    public:
+        /**
+         * Creates a new GetRequest object.
+         * @param file the sftp_file object which should be transferred.
+         * @param sb the attributes of that sftp_file object.
+         * @param maxPendingRequests the maximum number of parallel requests to start with.
+         *                           The more are pending the higher the potential memory
+         *                           foot print, however if the connection allows it
+         *                           we'll get better throughput.
+         */
+        GetRequest(sftp_file file, sftp_attributes sb, ushort maxPendingRequests = 128);
+        /**
+         * Removes all pending requests and closes the SFTP channel and attributes
+         * in order to avoid memory leaks.
+         */
+        ~GetRequest();
+
+        /**
+         * Starts up to maxPendingRequests file requests. Reading is performed in the
+         * via the readChunks method.
+         */
+        bool enqueueChunks();
+        /**
+         * Attempts to read all pending chunks in the given QByteArray.
+         * @param data the array into which the data should be saved (it should be empty).
+         * @return 0 on EOF or timeout, -1 on error and the number of bytes read otherwise.
+         */
+        int readChunks(QByteArray &data);
+
+    private:
+        struct Request {
+            /** Identifier as returned by the sftp_async_read_begin call */
+            int id;
+            /** The number of bytes expected to be returned */
+            uint32_t expectedLength;
+            /** The SSH start offset when this request was made */
+            uint64_t startOffset;
+        };
+
+        sftp_file mFile;
+        sftp_attributes mSb;
+        ushort mMaxPendingRequests;
+        QQueue<Request> pendingRequests;
     };
-  private:
-    sftp_file mFile;
-    sftp_attributes mSb;
-    ushort mMaxPendingRequests;
-    QQueue<Request> pendingRequests;
-  };
-
 
 private: // private methods
+    int authenticateKeyboardInteractive(KIO::AuthInfo &info);
 
-  int authenticateKeyboardInteractive(KIO::AuthInfo &info);
-
-  void reportError(const QUrl &url, const int err);
+    void reportError(const QUrl &url, const int err);
 
-  bool createUDSEntry(const QString &filename, const QByteArray &path,
-                      KIO::UDSEntry &entry, short int details);
+    bool createUDSEntry(const QString &filename, const QByteArray &path,
+                        KIO::UDSEntry &entry, short int details);
 
-  QString canonicalizePath(const QString &path);
-  void requiresUserNameRedirection();
-  void clearPubKeyAuthInfo();
-  bool sftpLogin();
-  bool sftpOpenConnection(const KIO::AuthInfo&);
-  void sftpSendWarning(int errorCode, const QString& url);
+    QString canonicalizePath(const QString &path);
+    void requiresUserNameRedirection();
+    void clearPubKeyAuthInfo();
+    bool sftpLogin();
+    bool sftpOpenConnection(const KIO::AuthInfo&);
+    void sftpSendWarning(int errorCode, const QString& url);
 
-  // Close without error() or finish() call (in case of errors for example)
-  void closeWithoutFinish();
+    // Close without error() or finish() call (in case of errors for example)
+    void closeWithoutFinish();
 
-  /**
+    /**
     * Status Code returned from ftpPut() and ftpGet(), used to select
     * source or destination url for error messages
     */
-  typedef enum {
-    Success,
-    ClientError,
-    ServerError
-  } StatusCode;
+    typedef enum {
+        Success,
+        ClientError,
+        ServerError
+    } StatusCode;
 
-  StatusCode sftpGet(const QUrl& url, int& errorCode, KIO::fileoffset_t offset = -1, int fd = -1);
-  StatusCode sftpPut(const QUrl& url, int permissions, KIO::JobFlags flags, int& errorCode, int fd = -1);
+    StatusCode sftpGet(const QUrl& url, int& errorCode, KIO::fileoffset_t offset = -1, int fd = -1);
+    StatusCode sftpPut(const QUrl& url, int permissions, KIO::JobFlags flags, int& errorCode, int fd = -1);
 
-  StatusCode sftpCopyGet(const QUrl& url, const QString& src, int permissions, KIO::JobFlags flags, int& errorCode);
-  StatusCode sftpCopyPut(const QUrl& url, const QString& dest, int permissions, KIO::JobFlags flags, int& errorCode);
+    StatusCode sftpCopyGet(const QUrl& url, const QString& src, int permissions, KIO::JobFlags flags, int& errorCode);
+    StatusCode sftpCopyPut(const QUrl& url, const QString& dest, int permissions, KIO::JobFlags flags, int& errorCode);
 
-  void fileSystemFreeSpace(const QUrl& url);  // KF6 TODO: Once a virtual fileSystemFreeSpace method in SlaveBase exists, override it
+    void fileSystemFreeSpace(const QUrl& url);  // KF6 TODO: Once a virtual fileSystemFreeSpace method in SlaveBase exists, override it
 };
 
 #endif
-- 
2.19.1


From f2f6508bcf5cc86fdee7b1f61633c8e1b82e9617 Mon Sep 17 00:00:00 2001
From: Harald Sitter <sitter@kde.org>
Date: Tue, 23 Oct 2018 16:25:58 +0200
Subject: [PATCH 21/22] [sftp] put request chunk debugging into own category

Summary:
it's excessively verbose and not necessarily useful unless one is actually
debugging request handling, so separating this from the general slave
debugging seems handy as one can enable one without the other.

CCBUG: 368877

Test Plan: builds, installs, has separate logging categories

Reviewers: asn, broulik, ngraham

Reviewed By: broulik

Subscribers: kde-frameworks-devel, kfm-devel

Tags: #dolphin, #frameworks

Differential Revision: https://phabricator.kde.org/D16387
---
 sftp/CMakeLists.txt | 5 +++++
 sftp/kio_sftp.cpp   | 5 +++--
 2 files changed, 8 insertions(+), 2 deletions(-)

diff --git a/sftp/CMakeLists.txt b/sftp/CMakeLists.txt
index c3252ff9..8eff6bc9 100644
--- a/sftp/CMakeLists.txt
+++ b/sftp/CMakeLists.txt
@@ -9,6 +9,11 @@ ecm_qt_declare_logging_category(kio_sftp_SRCS
     IDENTIFIER KIO_SFTP_LOG
     CATEGORY_NAME log_kio_sftp)
 
+ecm_qt_declare_logging_category(kio_sftp_SRCS
+    HEADER kio_sftp_trace_debug.h
+    IDENTIFIER KIO_SFTP_TRACE_LOG
+    CATEGORY_NAME log_kio_sftp.trace)
+
 add_library(kio_sftp MODULE ${kio_sftp_SRCS})
 target_link_libraries(kio_sftp
    KF5::KIOCore
diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index 24e3e05d..ef2a2b90 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -23,6 +23,7 @@
 
 #include <config-runtime.h>
 #include "kio_sftp_debug.h"
+#include "kio_sftp_trace_debug.h"
 #include <cerrno>
 #include <cstring>
 #include <utime.h>
@@ -2112,7 +2113,7 @@ sftpProtocol::GetRequest::GetRequest(sftp_file file, sftp_attributes sb, ushort
 bool sftpProtocol::GetRequest::enqueueChunks() {
     sftpProtocol::GetRequest::Request request;
 
-    qCDebug(KIO_SFTP_LOG) << "enqueueChunks";
+    qCDebug(KIO_SFTP_TRACE_LOG) << "enqueueChunks";
 
     while (pendingRequests.count() < mMaxPendingRequests) {
         request.expectedLength = MAX_XFER_BUF_SIZE;
@@ -2136,7 +2137,7 @@ bool sftpProtocol::GetRequest::enqueueChunks() {
         }
     }
 
-    qCDebug(KIO_SFTP_LOG) << "enqueueChunks done" << QString::number(pendingRequests.size());
+    qCDebug(KIO_SFTP_TRACE_LOG) << "enqueueChunks done" << QString::number(pendingRequests.size());
 
     return true;
 }
-- 
2.19.1


From 08d252fe214f362343516f1739d8ec3957ffbebc Mon Sep 17 00:00:00 2001
From: Andreas Schneider <asn@cryptomilk.org>
Date: Mon, 24 Sep 2018 14:23:56 +0200
Subject: [PATCH 22/22] [sftp] Add additional sftpProtocol::openConnection()
 for libssh 0.8.3+

Summary:
This uses the new known_hosts API and creates SHA256 fingerprints for
public key verifcation.

Signed-off-by: Andreas Schneider <asn@cryptomilk.org>

Differential Revision: https://phabricator.kde.org/D16538

(cherry picked from commit f857c73b9a23a32f6dcb8d4199fc1820482b3df1)
---
 sftp/kio_sftp.cpp | 334 +++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 333 insertions(+), 1 deletion(-)

diff --git a/sftp/kio_sftp.cpp b/sftp/kio_sftp.cpp
index ef2a2b90..1e962d1a 100644
--- a/sftp/kio_sftp.cpp
+++ b/sftp/kio_sftp.cpp
@@ -628,8 +628,339 @@ bool sftpProtocol::sftpOpenConnection (const AuthInfo& info)
 }
 
 
-void sftpProtocol::openConnection() {
+#if LIBSSH_VERSION_INT >= SSH_VERSION_INT(0, 8, 3)
+void sftpProtocol::openConnection()
+{
+    if (mConnected) {
+        return;
+    }
+
+    if (mHost.isEmpty()) {
+        qCDebug(KIO_SFTP_LOG) << "openConnection(): Need hostname...";
+        error(KIO::ERR_UNKNOWN_HOST, QString());
+        return;
+    }
+
+    AuthInfo info;
+    info.url.setScheme("sftp");
+    info.url.setHost(mHost);
+    if ( mPort > 0 && mPort != DEFAULT_SFTP_PORT ) {
+        info.url.setPort(mPort);
+    }
+    info.url.setUserName(mUsername);
+    info.username = mUsername;
+
+    // Check for cached authentication info if no password is specified...
+    if (mPassword.isEmpty()) {
+        qCDebug(KIO_SFTP_LOG) << "checking cache: info.username =" << info.username
+            << ", info.url =" << info.url.toDisplayString();
+        checkCachedAuthentication(info);
+    } else {
+        info.password = mPassword;
+    }
+
+    // Start the ssh connection.
+    QString msg;     // msg for dialog box
+    QString caption; // dialog box caption
+    unsigned char *hash = nullptr; // the server hash
+    size_t hlen;
+    ssh_key srv_pubkey = nullptr;
+    const char *srv_pubkey_type = nullptr;
+    char *fingerprint = nullptr;
+    enum ssh_known_hosts_e state;
+    int rc;
+
+    // Attempt to start a ssh session and establish a connection with the server.
+    if (!sftpOpenConnection(info)) {
+        return;
+    }
+
+    qCDebug(KIO_SFTP_LOG) << "Getting the SSH server hash";
+
+    /* get the hash */
+    rc = ssh_get_server_publickey(mSession, &srv_pubkey);
+    if (rc < 0) {
+        error(KIO::ERR_SLAVE_DEFINED, QString::fromUtf8(ssh_get_error(mSession)));
+        closeConnection();
+        return;
+    }
+
+    srv_pubkey_type = ssh_key_type_to_char(ssh_key_type(srv_pubkey));
+    if (srv_pubkey_type == nullptr) {
+        ssh_key_free(srv_pubkey);
+        error(KIO::ERR_SLAVE_DEFINED,
+              i18n("Could not get server public key type name"));
+        closeConnection();
+        return;
+    }
+
+    rc = ssh_get_publickey_hash(srv_pubkey,
+                                SSH_PUBLICKEY_HASH_SHA256,
+                                &hash,
+                                &hlen);
+    ssh_key_free(srv_pubkey);
+    if (rc != SSH_OK) {
+        error(KIO::ERR_SLAVE_DEFINED,
+              i18n("Could not create hash from server public key"));
+        closeConnection();
+        return;
+    }
+
+    fingerprint = ssh_get_fingerprint_hash(SSH_PUBLICKEY_HASH_SHA256,
+                                           hash,
+                                           hlen);
+    ssh_string_free_char((char *)hash);
+    if (fingerprint == nullptr) {
+        error(KIO::ERR_SLAVE_DEFINED,
+              i18n("Could not create fingerprint for server public key"));
+        closeConnection();
+        return;
+    }
+
+    qCDebug(KIO_SFTP_LOG) << "Checking if the SSH server is known";
+
+    /* check the server public key hash */
+    state = ssh_session_is_known_server(mSession);
+    switch (state) {
+        case SSH_KNOWN_HOSTS_OTHER:
+            ssh_string_free_char(fingerprint);
+            error(KIO::ERR_SLAVE_DEFINED,
+                  i18n("An %1 host key for this server was "
+                       "not found, but another type of key exists.\n"
+                       "An attacker might change the default server key to confuse your "
+                       "client into thinking the key does not exist.\n"
+                       "Please contact your system administrator.\n"
+                       "%2",
+                       QString::fromUtf8(srv_pubkey_type),
+                       QString::fromUtf8(ssh_get_error(mSession))));
+            closeConnection();
+            return;
+        case SSH_KNOWN_HOSTS_CHANGED:
+            error(KIO::ERR_SLAVE_DEFINED,
+                  i18n("The host key for the server %1 has changed.\n"
+                       "This could either mean that DNS SPOOFING is happening or the IP "
+                       "address for the host and its host key have changed at the same time.\n"
+                       "The fingerprint for the %2 key sent by the remote host is:\n"
+                       "  SHA256:%3\n"
+                       "Please contact your system administrator.\n%4",
+                       mHost,
+                       QString::fromUtf8(srv_pubkey_type),
+                       QString::fromUtf8(fingerprint),
+                       QString::fromUtf8(ssh_get_error(mSession))));
+            ssh_string_free_char(fingerprint);
+            closeConnection();
+            return;
+        case SSH_KNOWN_HOSTS_NOT_FOUND:
+        case SSH_KNOWN_HOSTS_UNKNOWN:
+            caption = i18n("Warning: Cannot verify host's identity.");
+            msg = i18n("The authenticity of host %1 cannot be established.\n"
+                       "The %2 key fingerprint is: %3\n"
+                       "Are you sure you want to continue connecting?",
+                       mHost,
+                       QString::fromUtf8(srv_pubkey_type),
+                       QString::fromUtf8(fingerprint));
+            ssh_string_free_char(fingerprint);
+
+            if (KMessageBox::Yes != messageBox(WarningYesNo, msg, caption)) {
+                closeConnection();
+                error(KIO::ERR_USER_CANCELED, QString());
+                return;
+            }
+
+            /* write the known_hosts file */
+            qCDebug(KIO_SFTP_LOG) << "Adding server to known_hosts file.";
+            rc = ssh_session_update_known_hosts(mSession);
+            if (rc != SSH_OK) {
+                error(KIO::ERR_USER_CANCELED,
+                      QString::fromUtf8(ssh_get_error(mSession)));
+                closeConnection();
+                return;
+            }
+            break;
+        case SSH_KNOWN_HOSTS_ERROR:
+            ssh_string_free_char(fingerprint);
+            error(KIO::ERR_SLAVE_DEFINED,
+                  QString::fromUtf8(ssh_get_error(mSession)));
+            return;
+        case SSH_KNOWN_HOSTS_OK:
+            break;
+    }
+
+    qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with the server";
+
+    // Try to login without authentication
+    rc = ssh_userauth_none(mSession, nullptr);
+    if (rc == SSH_AUTH_ERROR) {
+        closeConnection();
+        error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+        return;
+    }
+
+    // This NEEDS to be called after ssh_userauth_none() !!!
+    int method = ssh_auth_list(mSession);
+    if (rc != SSH_AUTH_SUCCESS && method == 0) {
+        closeConnection();
+        error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed. The server "
+                    "didn't send any authentication methods"));
+        return;
+    }
+
+    // Try to authenticate with public key first
+    if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_PUBLICKEY)) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with public key";
+        for(;;) {
+            rc = ssh_userauth_publickey_auto(mSession, nullptr, nullptr);
+            if (rc == SSH_AUTH_ERROR) {
+                qCDebug(KIO_SFTP_LOG) << "Public key authentication failed:" <<
+                    QString::fromUtf8(ssh_get_error(mSession));
+                closeConnection();
+                clearPubKeyAuthInfo();
+                error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+                return;
+            } else if (rc != SSH_AUTH_DENIED || !mPublicKeyAuthInfo || !mPublicKeyAuthInfo->isModified()) {
+                clearPubKeyAuthInfo();
+                break;
+            }
+        }
+    }
+
+    // Try to authenticate with GSSAPI
+    if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_GSSAPI_MIC)) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with GSSAPI";
+        rc = ssh_userauth_gssapi(mSession);
+        if (rc == SSH_AUTH_ERROR) {
+            qCDebug(KIO_SFTP_LOG) << "Public key authentication failed:" <<
+                QString::fromUtf8(ssh_get_error(mSession));
+            closeConnection();
+            error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+            return;
+        }
+    }
+
+    // Try to authenticate with keyboard interactive
+    if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_INTERACTIVE)) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with keyboard interactive";
+        AuthInfo info2 (info);
+        rc = authenticateKeyboardInteractive(info2);
+        if (rc == SSH_AUTH_SUCCESS) {
+            info = info2;
+        } else if (rc == SSH_AUTH_ERROR) {
+            qCDebug(KIO_SFTP_LOG) << "Keyboard interactive authentication failed:"
+                << QString::fromUtf8(ssh_get_error(mSession));
+            closeConnection();
+            error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+            return;
+        }
+    }
+
+    // Try to authenticate with password
+    if (rc != SSH_AUTH_SUCCESS && (method & SSH_AUTH_METHOD_PASSWORD)) {
+        qCDebug(KIO_SFTP_LOG) << "Trying to authenticate with password";
+
+        info.caption = i18n("SFTP Login");
+        info.prompt = i18n("Please enter your username and password.");
+        info.comment = info.url.url();
+        info.commentLabel = i18n("Site:");
+        bool isFirstLoginAttempt = true;
+
+        for(;;) {
+            if (!isFirstLoginAttempt || info.password.isEmpty()) {
+                info.keepPassword = true; // make the "keep Password" check box visible to the user.
+                info.setModified(false);
+
+                QString username (info.username);
+                const QString errMsg(isFirstLoginAttempt ? QString() : i18n("Incorrect username or password"));
+
+                qCDebug(KIO_SFTP_LOG) << "Username:" << username << "first attempt?"
+                    << isFirstLoginAttempt << "error:" << errMsg;
+
+                // Handle user canceled or dialog failed to open...
+
+                int errCode = openPasswordDialogV2(info, errMsg);
+                if (errCode != 0) {
+                    qCDebug(KIO_SFTP_LOG) << "User canceled password/retry dialog";
+                    closeConnection();
+                    error(errCode, QString());
+                    return;
+                }
 
+                // If the user name changes, we have to restablish connection again
+                // since the user name must always be set before calling ssh_connect.
+                if (wasUsernameChanged(username, info)) {
+                    qCDebug(KIO_SFTP_LOG) << "Username changed to" << info.username;
+                    if (!info.url.userName().isEmpty()) {
+                        info.url.setUserName(info.username);
+                    }
+                    closeConnection();
+                    if (!sftpOpenConnection(info)) {
+                        return;
+                    }
+                }
+            }
+
+            rc = ssh_userauth_password(mSession, info.username.toUtf8().constData(), info.password.toUtf8().constData());
+            if (rc == SSH_AUTH_SUCCESS) {
+                break;
+            } else if (rc == SSH_AUTH_ERROR) {
+                qCDebug(KIO_SFTP_LOG) << "Password authentication failed:"
+                    << QString::fromUtf8(ssh_get_error(mSession));
+                closeConnection();
+                error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+                return;
+            }
+
+            isFirstLoginAttempt = false; // failed attempt to login.
+            info.password.clear();       // clear the password after failed attempts.
+        }
+    }
+
+    // If we're still not authenticated then we need to leave.
+    if (rc != SSH_AUTH_SUCCESS) {
+        error(KIO::ERR_COULD_NOT_LOGIN, i18n("Authentication failed."));
+        return;
+    }
+
+    // start sftp session
+    qCDebug(KIO_SFTP_LOG) << "Trying to request the sftp session";
+    mSftp = sftp_new(mSession);
+    if (mSftp == nullptr) {
+        closeConnection();
+        error(KIO::ERR_COULD_NOT_LOGIN, i18n("Unable to request the SFTP subsystem. "
+                    "Make sure SFTP is enabled on the server."));
+        return;
+    }
+
+    qCDebug(KIO_SFTP_LOG) << "Trying to initialize the sftp session";
+    if (sftp_init(mSftp) < 0) {
+        closeConnection();
+        error(KIO::ERR_COULD_NOT_LOGIN, i18n("Could not initialize the SFTP session."));
+        return;
+    }
+
+    // Login succeeded!
+    infoMessage(i18n("Successfully connected to %1", mHost));
+    if (info.keepPassword) {
+        qCDebug(KIO_SFTP_LOG) << "Caching info.username = " << info.username
+            << ", info.url = " << info.url.toDisplayString();
+        cacheAuthentication(info);
+    }
+
+    // Update the original username in case it was changed!
+    if (!mUsername.isEmpty()) {
+        mUsername = info.username;
+    }
+
+    setTimeoutSpecialCommand(KIO_SFTP_SPECIAL_TIMEOUT);
+
+    mConnected = true;
+    connected();
+
+    info.password.fill('x');
+    info.password.clear();
+}
+#else // < 0.8.0
+void sftpProtocol::openConnection()
+{
     if (mConnected) {
         return;
     }
@@ -925,6 +1256,7 @@ void sftpProtocol::openConnection() {
     info.password.fill('x');
     info.password.clear();
 }
+#endif // 0.8.0
 
 void sftpProtocol::closeConnection() {
     qCDebug(KIO_SFTP_LOG);
-- 
2.19.1

