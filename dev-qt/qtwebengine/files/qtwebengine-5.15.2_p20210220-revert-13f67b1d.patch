From eda0a510942e20d33aa4508ecb407a37fe29955d Mon Sep 17 00:00:00 2001
From: Andreas Sturmlechner <asturm@gentoo.org>
Date: Sun, 21 Feb 2021 19:52:31 +0100
Subject: [PATCH] Revert "[Backport] CVE-2021-21149: Stack overflow in Data
 Transfer"
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

(also includes:
Revert "FIXUP: [Backport] CVE-2021-21149: Stack overflow in Data Transfer")

This reverts commit d77379c520980bea4f53e093c0a130d57155c2ad.
This reverts commit 13f67b1dc46c5b2b61b17a201f1f8b28f8e476cb.

Build error:

chromium/ui/gfx/x/connection.cc: In member function ‘bool x11::Connection::HasPendingResponses() const’:
chromium/ui/gfx/x/connection.cc:428:23: error: passing ‘const x11::Connection’ as ‘this’ argument discards qualifiers [-fpermissive]
  428 |   return HasNextEvent() || HasNextResponse();
      |                       ^
chromium/ui/gfx/x/connection.cc:348:6: note:   in call to ‘bool x11::Connection::HasNextEvent()’
  348 | bool Connection::HasNextEvent() {
      |      ^~~~~~~~~~
---
 chromium/ui/base/x/x11_util.cc                | 20 ++++++++++---------
 .../events/platform/x11/x11_event_source.cc   |  5 ++---
 chromium/ui/gfx/x/connection.cc               | 19 +++++-------------
 chromium/ui/gfx/x/connection.h                | 12 ++++-------
 chromium/ui/gfx/x/event.h                     |  2 --
 5 files changed, 22 insertions(+), 36 deletions(-)

diff --git a/src/3rdparty/chromium/ui/base/x/x11_util.cc b/src/3rdparty/chromium/ui/base/x/x11_util.cc
index 63bc2df4f85..5de86e2b41a 100644
--- a/src/3rdparty/chromium/ui/base/x/x11_util.cc
+++ b/src/3rdparty/chromium/ui/base/x/x11_util.cc
@@ -375,14 +375,16 @@ int CoalescePendingMotionEvents(const x11::Event* x11_event,
 
   conn->ReadResponses();
   if (motion) {
-    for (auto& next_event : conn->events()) {
+    for (auto it = conn->events().begin(); it != conn->events().end();) {
+      const auto& next_event = *it;
       // Discard all but the most recent motion event that targets the same
       // window with unchanged state.
       const auto* next_motion = next_event.As<x11::MotionNotifyEvent>();
       if (next_motion && next_motion->event == motion->event &&
           next_motion->child == motion->child &&
           next_motion->state == motion->state) {
-        *last_event = std::move(next_event);
+        *last_event = std::move(*it);
+        it = conn->events().erase(it);
       } else {
         break;
       }
@@ -392,8 +394,8 @@ int CoalescePendingMotionEvents(const x11::Event* x11_event,
            device->opcode == x11::Input::DeviceEvent::TouchUpdate);
 
     auto* ddmx11 = ui::DeviceDataManagerX11::GetInstance();
-    for (auto& event : conn->events()) {
-      auto* next_device = event.As<x11::Input::DeviceEvent>();
+    for (auto it = conn->events().begin(); it != conn->events().end();) {
+      auto* next_device = it->As<x11::Input::DeviceEvent>();
 
       if (!next_device)
         break;
@@ -404,13 +406,13 @@ int CoalescePendingMotionEvents(const x11::Event* x11_event,
       // always be at least one pending.
       if (!ui::TouchFactory::GetInstance()->ShouldProcessDeviceEvent(
               *next_device)) {
-        event = x11::Event();
+        it = conn->events().erase(it);
         continue;
       }
 
       if (next_device->opcode == device->opcode &&
-          !ddmx11->IsCMTGestureEvent(event) &&
-          ddmx11->GetScrollClassEventDetail(event) == SCROLL_TYPE_NO_SCROLL) {
+          !ddmx11->IsCMTGestureEvent(*it) &&
+          ddmx11->GetScrollClassEventDetail(*it) == SCROLL_TYPE_NO_SCROLL) {
         // Confirm that the motion event is targeted at the same window
         // and that no buttons or modifiers have changed.
         if (device->event == next_device->event &&
@@ -421,12 +423,12 @@ int CoalescePendingMotionEvents(const x11::Event* x11_event,
             device->mods.latched == next_device->mods.latched &&
             device->mods.locked == next_device->mods.locked &&
             device->mods.effective == next_device->mods.effective) {
-          *last_event = std::move(event);
+          *last_event = std::move(*it);
+          it = conn->events().erase(it);
           num_coalesced++;
           continue;
         }
       }
-
       break;
     }
   }
diff --git a/src/3rdparty/chromium/ui/events/platform/x11/x11_event_source.cc b/src/3rdparty/chromium/ui/events/platform/x11/x11_event_source.cc
index bfead5362ff..b44357a7baf 100644
--- a/src/3rdparty/chromium/ui/events/platform/x11/x11_event_source.cc
+++ b/src/3rdparty/chromium/ui/events/platform/x11/x11_event_source.cc
@@ -244,9 +244,8 @@ x11::Time X11EventSource::GetCurrentServerTime() {
   };
 
   auto& events = connection_->events();
-  auto it = std::find_if(events.begin(), events.end(), pred);
-  if (it != events.end())
-    *it = x11::Event();
+  events.erase(std::remove_if(events.begin(), events.end(), pred),
+               events.end());
   return time;
 }
 
diff --git a/src/3rdparty/chromium/ui/gfx/x/connection.cc b/src/3rdparty/chromium/ui/gfx/x/connection.cc
index 0afbac2c605..e3ebed46377 100644
--- a/src/3rdparty/chromium/ui/gfx/x/connection.cc
+++ b/src/3rdparty/chromium/ui/gfx/x/connection.cc
@@ -345,15 +345,6 @@ bool Connection::HasNextResponse() const {
                             requests_.front().sequence) >= 0;
 }
 
-bool Connection::HasNextEvent() {
-  while (!events_.empty()) {
-    if (events_.front().Initialized())
-      return true;
-    events_.pop_front();
-  }
-  return false;
-}
-
 int Connection::GetFd() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   return Ready() ? xcb_get_file_descriptor(XcbConnection()) : -1;
@@ -411,7 +402,7 @@ void Connection::ReadResponses() {
 
 Event Connection::WaitForNextEvent() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  if (HasNextEvent()) {
+  if (!events_.empty()) {
     Event event = std::move(events_.front());
     events_.pop_front();
     return event;
@@ -425,7 +416,7 @@ Event Connection::WaitForNextEvent() {
 
 bool Connection::HasPendingResponses() const {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  return HasNextEvent() || HasNextResponse();
+  return !events_.empty() || HasNextResponse();
 }
 
 const Connection::VisualInfo* Connection::GetVisualInfoFromId(
@@ -503,7 +494,7 @@ void Connection::Dispatch(Delegate* delegate) {
   };
 
   auto process_next_event = [&] {
-    DCHECK(HasNextEvent());
+    DCHECK(!events_.empty());
 
     Event event = std::move(events_.front());
     events_.pop_front();
@@ -516,7 +507,7 @@ void Connection::Dispatch(Delegate* delegate) {
     Flush();
     ReadResponses();
 
-    if (HasNextResponse() && HasNextEvent()) {
+    if (HasNextResponse() && !events_.empty()) {
       if (!events_.front().sequence_valid()) {
         process_next_event();
         continue;
@@ -534,7 +525,7 @@ void Connection::Dispatch(Delegate* delegate) {
         process_next_event();
     } else if (HasNextResponse()) {
       process_next_response();
-    } else if (HasNextEvent()) {
+    } else if (!events_.empty()) {
       process_next_event();
     } else {
       break;
diff --git a/src/3rdparty/chromium/ui/gfx/x/connection.h b/src/3rdparty/chromium/ui/gfx/x/connection.h
index 73a306a2ca1..8880e408dfc 100644
--- a/src/3rdparty/chromium/ui/gfx/x/connection.h
+++ b/src/3rdparty/chromium/ui/gfx/x/connection.h
@@ -5,10 +5,10 @@
 #ifndef UI_GFX_X_CONNECTION_H_
 #define UI_GFX_X_CONNECTION_H_
 
+#include <list>
 #include <queue>
 
 #include "base/component_export.h"
-#include "base/containers/circular_deque.h"
 #include "base/sequence_checker.h"
 #include "ui/events/platform/platform_event_source.h"
 #include "ui/gfx/x/event.h"
@@ -137,10 +137,8 @@ class COMPONENT_EXPORT(X11) Connection : public XProto,
 
   KeySym KeycodeToKeysym(uint32_t keycode, unsigned int modifiers);
 
-  // Access the event buffer.  Clients may modify the queue, including
-  // "deleting" events by setting events[i] = x11::Event(), which will
-  // guarantee all calls to x11::Event::As() will return nullptr.
-  base::circular_deque<Event>& events() {
+  // Access the event buffer.  Clients can add, delete, or modify events.
+  std::list<Event>& events() {
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     return events_;
   }
@@ -174,8 +172,6 @@ class COMPONENT_EXPORT(X11) Connection : public XProto,
 
   bool HasNextResponse() const;
 
-  bool HasNextEvent();
-
   void PreDispatchEvent(const Event& event);
 
   int ScreenIndexFromRootWindow(x11::Window root) const;
@@ -209,7 +205,7 @@ class COMPONENT_EXPORT(X11) Connection : public XProto,
   uint8_t mode_switch_ = 0;
   uint8_t num_lock_ = 0;
 
-  base::circular_deque<Event> events_;
+  std::list<Event> events_;
 
   std::queue<Request> requests_;
 
diff --git a/src/3rdparty/chromium/ui/gfx/x/event.h b/src/3rdparty/chromium/ui/gfx/x/event.h
index b370b0f9a95..7e3d41dc7ce 100644
--- a/src/3rdparty/chromium/ui/gfx/x/event.h
+++ b/src/3rdparty/chromium/ui/gfx/x/event.h
@@ -76,8 +76,6 @@ class COMPONENT_EXPORT(X11) Event {
       *window_ = window;
   }
 
-  bool Initialized() const { return deleter_; }
-
  private:
   friend void ReadEvent(Event* event,
                         Connection* connection,
-- 
2.30.1

